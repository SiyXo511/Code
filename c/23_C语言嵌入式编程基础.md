# C语言嵌入式编程基础

本教程将学习C语言在嵌入式系统中的应用，包括内存管理、寄存器操作、中断处理等内容。

## 1. 内存映射寄存器

### 寄存器操作

```c
#include <stdint.h>

// 寄存器地址定义（示例：假设的硬件地址）
#define GPIO_BASE_ADDR   0x40000000
#define GPIO_DATA_REG    (*(volatile uint32_t *)(GPIO_BASE_ADDR + 0x00))
#define GPIO_DIR_REG     (*(volatile uint32_t *)(GPIO_BASE_ADDR + 0x04))
#define GPIO_SET_REG     (*(volatile uint32_t *)(GPIO_BASE_ADDR + 0x08))
#define GPIO_CLEAR_REG   (*(volatile uint32_t *)(GPIO_BASE_ADDR + 0x0C))

// 位字段定义
#define GPIO_PIN0    (1 << 0)
#define GPIO_PIN1    (1 << 1)
#define GPIO_PIN2    (1 << 2)

// GPIO操作函数
void gpio_set_pin(int pin) {
    GPIO_SET_REG |= (1 << pin);
}

void gpio_clear_pin(int pin) {
    GPIO_CLEAR_REG |= (1 << pin);
}

void gpio_set_direction(int pin, int direction) {
    if (direction) {
        GPIO_DIR_REG |= (1 << pin);  // 输出
    } else {
        GPIO_DIR_REG &= ~(1 << pin);  // 输入
    }
}

uint32_t gpio_read_pin(int pin) {
    return (GPIO_DATA_REG >> pin) & 0x01;
}
```

### volatile关键字

```c
#include <stdint.h>

// volatile告诉编译器不要优化，每次都从内存读取
volatile uint32_t *timer_reg = (volatile uint32_t *)0x10000000;
volatile uint32_t *status_reg = (volatile uint32_t *)0x10000004;

void wait_for_timer() {
    // 等待定时器溢出
    while ((*status_reg & 0x01) == 0) {
        // 空循环，等待标志位
    }
    // 清除标志位
    *status_reg &= ~0x01;
}

uint32_t read_timer() {
    return *timer_reg;  // 每次都从寄存器读取
}
```

## 2. 位操作在嵌入式中的应用

### 位掩码操作

```c
#include <stdint.h>

// 状态寄存器位定义
#define STATUS_READY      (1 << 0)
#define STATUS_ERROR      (1 << 1)
#define STATUS_BUSY       (1 << 2)
#define STATUS_COMPLETE   (1 << 3)

volatile uint32_t *status_reg = (volatile uint32_t *)0x20000000;

// 检查状态位
int is_ready() {
    return (*status_reg & STATUS_READY) != 0;
}

int is_error() {
    return (*status_reg & STATUS_ERROR) != 0;
}

// 设置状态位
void set_ready() {
    *status_reg |= STATUS_READY;
}

void clear_error() {
    *status_reg &= ~STATUS_ERROR;
}

// 切换状态位
void toggle_busy() {
    *status_reg ^= STATUS_BUSY;
}
```

### 位字段操作

```c
#include <stdint.h>

// 使用结构体位域定义寄存器
typedef struct {
    uint32_t mode        : 2;   // 模式位 [0:1]
    uint32_t reserved    : 2;   // 保留位
    uint32_t enable      : 1;   // 使能位 [4]
    uint32_t interrupt   : 1;   // 中断使能 [5]
    uint32_t reserved2   : 26;  // 保留位
} ControlReg;

// 使用联合体访问寄存器
typedef union {
    uint32_t value;
    ControlReg bits;
} ControlRegister;

#define CONTROL_REG_ADDR  0x30000000
volatile ControlRegister *ctrl_reg = (volatile ControlRegister *)CONTROL_REG_ADDR;

void configure_device() {
    ctrl_reg->bits.mode = 0x2;       // 设置模式为2
    ctrl_reg->bits.enable = 1;       // 使能设备
    ctrl_reg->bits.interrupt = 1;    // 使能中断
}
```

## 3. 中断处理

### 中断服务程序

```c
#include <stdint.h>

// 中断向量表（简化示例）
typedef void (*InterruptHandler)(void);

// 中断处理函数
volatile int interrupt_count = 0;

void timer_interrupt_handler(void) {
    interrupt_count++;
    // 清除中断标志
    // clear_interrupt_flag();
}

void uart_interrupt_handler(void) {
    // 处理UART中断
    // uint8_t data = read_uart_data();
}

// 注册中断处理函数
void register_interrupt(int irq_number, InterruptHandler handler) {
    // 中断向量表[irq_number] = handler;
}
```

## 4. 内存对齐和打包

### 结构体打包

```c
#include <stdio.h>
#include <stdint.h>

// 普通结构体（可能有很多填充）
struct UnpackedStruct {
    uint8_t a;   // 1字节
    uint32_t b;  // 4字节（会有3字节填充）
    uint16_t c;  // 2字节
    // 总大小可能是12字节
};

// 打包结构体（节省空间）
struct PackedStruct {
    uint8_t a;
    uint32_t b;
    uint16_t c;
} __attribute__((packed));
// 总大小是7字节

// 手动对齐的结构体
struct AlignedStruct {
    uint8_t a;
    uint8_t padding[3];  // 手动填充
    uint32_t b;
    uint16_t c;
    uint8_t padding2[2];  // 手动填充
};

int main() {
    printf("UnpackedStruct大小: %lu\n", sizeof(struct UnpackedStruct));
    printf("PackedStruct大小: %lu\n", sizeof(struct PackedStruct));
    printf("AlignedStruct大小: %lu\n", sizeof(struct AlignedStruct));
    
    return 0;
}
```

## 5. 延迟和计时

### 精确延迟

```c
#include <stdint.h>

// 忙等待延迟（微秒级）
void delay_us(uint32_t microseconds) {
    // 假设系统时钟频率
    const uint32_t cycles_per_us = 100;  // 需要根据实际系统调整
    uint32_t cycles = microseconds * cycles_per_us;
    
    for (volatile uint32_t i = 0; i < cycles; i++) {
        // 空循环
    }
}

// 毫秒级延迟
void delay_ms(uint32_t milliseconds) {
    for (uint32_t i = 0; i < milliseconds; i++) {
        delay_us(1000);
    }
}

// 使用定时器实现精确延迟
volatile uint32_t *timer_counter = (volatile uint32_t *)0x40000000;

void delay_us_timer(uint32_t microseconds) {
    uint32_t start = *timer_counter;
    uint32_t target = start + microseconds;
    
    while (*timer_counter < target) {
        // 等待
    }
}
```

## 6. 看门狗定时器

### 看门狗实现

```c
#include <stdint.h>

volatile uint32_t *watchdog_reg = (volatile uint32_t *)0x50000000;

// 喂狗函数（防止系统重启）
void watchdog_feed() {
    *watchdog_reg = 0xAA55;  // 写入特定值复位看门狗
}

// 初始化看门狗
void watchdog_init(uint32_t timeout_ms) {
    // 配置看门狗超时时间
    // ...
    watchdog_feed();
}

// 看门狗服务线程
void* watchdog_task(void *arg) {
    while (1) {
        delay_ms(1000);  // 每秒喂一次狗
        watchdog_feed();
    }
    return NULL;
}
```

## 7. 嵌入式系统内存管理

### 静态内存分配

```c
#include <stdint.h>
#include <stdlib.h>

// 嵌入式系统中通常使用静态内存池
#define POOL_SIZE 1024
#define BLOCK_SIZE 32
#define NUM_BLOCKS (POOL_SIZE / BLOCK_SIZE)

static uint8_t memory_pool[POOL_SIZE];
static uint8_t block_status[NUM_BLOCKS];  // 0=空闲, 1=已分配

void* embedded_malloc(size_t size) {
    if (size > BLOCK_SIZE) {
        return NULL;  // 分配失败
    }
    
    // 查找空闲块
    for (int i = 0; i < NUM_BLOCKS; i++) {
        if (block_status[i] == 0) {
            block_status[i] = 1;
            return memory_pool + (i * BLOCK_SIZE);
        }
    }
    
    return NULL;  // 内存不足
}

void embedded_free(void *ptr) {
    if (ptr < memory_pool || ptr >= memory_pool + POOL_SIZE) {
        return;  // 无效指针
    }
    
    int index = ((uint8_t *)ptr - memory_pool) / BLOCK_SIZE;
    if (index >= 0 && index < NUM_BLOCKS) {
        block_status[index] = 0;
    }
}
```

## 8. 低功耗编程

### 休眠模式

```c
#include <stdint.h>

volatile uint32_t *power_control = (volatile uint32_t *)0x60000000;

#define POWER_MODE_NORMAL   0
#define POWER_MODE_SLEEP    1
#define POWER_MODE_DEEP     2

void enter_sleep_mode() {
    // 保存状态
    // ...
    
    // 进入休眠模式
    *power_control = POWER_MODE_SLEEP;
    
    // 等待中断唤醒
    asm("wfi");  // Wait for Interrupt
    
    // 恢复状态
    // ...
}

void enter_deep_sleep() {
    // 关闭不必要的模块
    // ...
    
    *power_control = POWER_MODE_DEEP;
    asm("wfi");
}
```

## 9. 嵌入式调试

### 调试输出（UART）

```c
#include <stdint.h>

volatile uint32_t *uart_data_reg = (volatile uint32_t *)0x70000000;
volatile uint32_t *uart_status_reg = (volatile uint32_t *)0x70000004;

#define UART_TX_READY (1 << 0)

void uart_putchar(char c) {
    // 等待发送缓冲区就绪
    while ((*uart_status_reg & UART_TX_READY) == 0) {
        // 等待
    }
    
    // 发送字符
    *uart_data_reg = (uint32_t)c;
}

void uart_puts(const char *str) {
    while (*str) {
        uart_putchar(*str++);
    }
}

// 简单的printf实现
void embedded_printf(const char *format, ...) {
    // 简化实现：只支持基本格式
    // 实际应用中可能需要完整的printf实现
    uart_puts(format);
}
```

## 10. 综合示例：LED控制

```c
#include <stdint.h>

// GPIO寄存器定义
#define GPIO_BASE         0x40000000
#define GPIO_OUTPUT       (*(volatile uint32_t *)(GPIO_BASE + 0x00))
#define GPIO_DIR          (*(volatile uint32_t *)(GPIO_BASE + 0x04))

#define LED_PIN           0  // LED连接的GPIO引脚

// LED控制
void led_init() {
    GPIO_DIR |= (1 << LED_PIN);  // 设置为输出
}

void led_on() {
    GPIO_OUTPUT |= (1 << LED_PIN);
}

void led_off() {
    GPIO_OUTPUT &= ~(1 << LED_PIN);
}

void led_toggle() {
    GPIO_OUTPUT ^= (1 << LED_PIN);
}

// LED闪烁程序
void led_blink(uint32_t delay_ms) {
    led_toggle();
    delay_ms(delay_ms);
}

int main() {
    led_init();
    
    while (1) {
        led_blink(500);  // 500ms闪烁一次
    }
    
    return 0;
}
```

## 练习

1. 实现一个完整的GPIO驱动程序
2. 创建一个中断驱动的按键检测系统
3. 实现一个UART通信库
4. 编写一个嵌入式系统的看门狗服务程序

