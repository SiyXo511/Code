# C语言性能优化技巧

本教程将学习C语言中的性能优化技巧，包括编译器优化、算法优化、内存优化等内容。

## 1. 编译器优化选项

### GCC 优化选项

```c
// 编译时使用不同优化级别
// gcc -O0 program.c  // 无优化（调试用）
// gcc -O1 program.c  // 基本优化
// gcc -O2 program.c  // 推荐优化级别
// gcc -O3 program.c  // 激进优化
// gcc -Os program.c  // 优化代码大小

#include <stdio.h>

// 示例：优化前后的代码对比
int sum_array_slow(int arr[], int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }
    return sum;
}

// 优化版本：使用局部变量缓存
int sum_array_fast(int arr[], int n) {
    int sum = 0;
    register int *p = arr;  // 建议使用寄存器
    register int i = n;
    
    while (i--) {
        sum += *p++;
    }
    return sum;
}

int main() {
    int arr[1000];
    for (int i = 0; i < 1000; i++) {
        arr[i] = i;
    }
    
    int result1 = sum_array_slow(arr, 1000);
    int result2 = sum_array_fast(arr, 1000);
    
    printf("慢版本结果: %d\n", result1);
    printf("快版本结果: %d\n", result2);
    
    return 0;
}
```

## 2. 内联函数

### inline 关键字

```c
#include <stdio.h>

// 内联函数：减少函数调用开销
static inline int max(int a, int b) {
    return (a > b) ? a : b;
}

static inline int min(int a, int b) {
    return (a < b) ? a : b;
}

static inline int square(int x) {
    return x * x;
}

int main() {
    int a = 10, b = 20;
    
    // 这些函数调用会被内联展开
    printf("max(%d, %d) = %d\n", a, b, max(a, b));
    printf("min(%d, %d) = %d\n", a, b, min(a, b));
    printf("square(%d) = %d\n", a, square(a));
    
    return 0;
}
```

## 3. 循环优化

### 循环展开（Loop Unrolling）

```c
#include <stdio.h>
#include <time.h>

// 未优化版本
int sum_loop_unrolled(int arr[], int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }
    return sum;
}

// 手动循环展开
int sum_loop_optimized(int arr[], int n) {
    int sum = 0;
    int i;
    
    // 展开4次
    for (i = 0; i < n - 3; i += 4) {
        sum += arr[i];
        sum += arr[i + 1];
        sum += arr[i + 2];
        sum += arr[i + 3];
    }
    
    // 处理剩余元素
    for (; i < n; i++) {
        sum += arr[i];
    }
    
    return sum;
}

int main() {
    const int SIZE = 1000000;
    int *arr = (int *)malloc(SIZE * sizeof(int));
    
    for (int i = 0; i < SIZE; i++) {
        arr[i] = i;
    }
    
    clock_t start, end;
    double cpu_time_used;
    
    start = clock();
    int result1 = sum_loop_unrolled(arr, SIZE);
    end = clock();
    cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC;
    printf("未优化版本: %d, 时间: %f 秒\n", result1, cpu_time_used);
    
    start = clock();
    int result2 = sum_loop_optimized(arr, SIZE);
    end = clock();
    cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC;
    printf("优化版本: %d, 时间: %f 秒\n", result2, cpu_time_used);
    
    free(arr);
    return 0;
}
```

### 循环优化技巧

```c
#include <stdio.h>

// 1. 避免在循环中重复计算
// 差：
void bad_loop(int arr[], int n) {
    for (int i = 0; i < strlen("constant string"); i++) {  // 每次都计算
        arr[i] = i;
    }
}

// 好：
void good_loop(int arr[], int n) {
    int len = strlen("constant string");  // 预先计算
    for (int i = 0; i < len; i++) {
        arr[i] = i;
    }
}

// 2. 减少循环嵌套
// 差：
void bad_nested(int matrix[][100], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (matrix[i][j] > 0) {
                matrix[i][j] = matrix[i][j] * 2;
            }
        }
    }
}

// 好：减少分支预测失败
void good_nested(int matrix[][100], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            matrix[i][j] = (matrix[i][j] > 0) ? matrix[i][j] * 2 : matrix[i][j];
        }
    }
}

// 3. 缓存友好的内存访问
void cache_friendly(int matrix[][1000], int n) {
    // 按行访问（缓存友好）
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            matrix[i][j] = i + j;
        }
    }
}
```

## 4. 内存访问优化

### 缓存优化

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define SIZE 10000

// 缓存不友好：按列访问
void column_major(int matrix[][SIZE], int n) {
    for (int j = 0; j < n; j++) {
        for (int i = 0; i < n; i++) {
            matrix[i][j] = i + j;
        }
    }
}

// 缓存友好：按行访问
void row_major(int matrix[][SIZE], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            matrix[i][j] = i + j;
        }
    }
}

int main() {
    int (*matrix)[SIZE] = (int (*)[SIZE])malloc(SIZE * SIZE * sizeof(int));
    
    clock_t start, end;
    
    start = clock();
    column_major(matrix, SIZE);
    end = clock();
    printf("按列访问时间: %f 秒\n", 
           ((double)(end - start)) / CLOCKS_PER_SEC);
    
    start = clock();
    row_major(matrix, SIZE);
    end = clock();
    printf("按行访问时间: %f 秒\n", 
           ((double)(end - start)) / CLOCKS_PER_SEC);
    
    free(matrix);
    return 0;
}
```

### 内存对齐优化

```c
#include <stdio.h>
#include <stddef.h>

// 对齐的结构体（更高效）
struct AlignedStruct {
    double d;    // 8字节对齐
    int i;       // 4字节
    char c;      // 1字节
    // 编译器会自动填充
};

// 手动对齐的结构体
struct PackedStruct {
    int i;
    char c;
    double d;
} __attribute__((packed));

int main() {
    printf("对齐结构体大小: %lu\n", sizeof(struct AlignedStruct));
    printf("打包结构体大小: %lu\n", sizeof(struct PackedStruct));
    
    // 对齐的结构体访问更快
    struct AlignedStruct aligned;
    aligned.d = 3.14;
    aligned.i = 10;
    aligned.c = 'A';
    
    return 0;
}
```

## 5. 函数调用优化

### 减少函数调用开销

```c
#include <stdio.h>

// 宏替代小函数（减少调用开销）
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define ABS(x) ((x) < 0 ? -(x) : (x))

// 内联函数
static inline int square_inline(int x) {
    return x * x;
}

// 函数指针（可能较慢）
int square_func(int x) {
    return x * x;
}

int main() {
    int x = 10, y = 20;
    
    // 使用宏（最快）
    int max_val = MAX(x, y);
    
    // 使用内联函数（快）
    int square1 = square_inline(x);
    
    // 使用普通函数（较慢）
    int square2 = square_func(x);
    
    printf("max: %d, square1: %d, square2: %d\n", 
           max_val, square1, square2);
    
    return 0;
}
```

## 6. 算法优化

### 时间复杂度优化

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// O(n²) 算法：查找重复元素（慢）
int has_duplicate_slow(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (arr[i] == arr[j]) {
                return 1;
            }
        }
    }
    return 0;
}

// O(n) 算法：使用哈希表思想（快）
int has_duplicate_fast(int arr[], int n, int max_val) {
    // 假设数组值在0到max_val之间
    int *seen = (int *)calloc(max_val + 1, sizeof(int));
    
    for (int i = 0; i < n; i++) {
        if (seen[arr[i]]) {
            free(seen);
            return 1;
        }
        seen[arr[i]] = 1;
    }
    
    free(seen);
    return 0;
}

int main() {
    const int SIZE = 1000;
    int *arr = (int *)malloc(SIZE * sizeof(int));
    
    for (int i = 0; i < SIZE; i++) {
        arr[i] = i;
    }
    arr[SIZE - 1] = 0;  // 添加重复元素
    
    clock_t start, end;
    
    start = clock();
    int result1 = has_duplicate_slow(arr, SIZE);
    end = clock();
    printf("慢算法: %d, 时间: %f 秒\n", 
           result1, ((double)(end - start)) / CLOCKS_PER_SEC);
    
    start = clock();
    int result2 = has_duplicate_fast(arr, SIZE, SIZE);
    end = clock();
    printf("快算法: %d, 时间: %f 秒\n", 
           result2, ((double)(end - start)) / CLOCKS_PER_SEC);
    
    free(arr);
    return 0;
}
```

## 7. 预计算和查找表

### 查找表优化

```c
#include <stdio.h>
#include <math.h>

// 预计算的查找表
static const int factorial_table[] = {
    1,      // 0!
    1,      // 1!
    2,      // 2!
    6,      // 3!
    24,     // 4!
    120,    // 5!
    720,    // 6!
    5040,   // 7!
    40320,  // 8!
    362880, // 9!
    3628800 // 10!
};

// 使用查找表（快速）
int factorial_lookup(int n) {
    if (n >= 0 && n <= 10) {
        return factorial_table[n];
    }
    return -1;  // 超出范围
}

// 计算方式（慢）
int factorial_calc(int n) {
    if (n <= 1) return 1;
    int result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}

int main() {
    printf("查找表方式: %d! = %d\n", 5, factorial_lookup(5));
    printf("计算方式: %d! = %d\n", 5, factorial_calc(5));
    
    return 0;
}
```

## 8. 分支预测优化

### 优化条件分支

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// 未优化：分支预测困难
int sum_even_slow(int arr[], int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        if (arr[i] % 2 == 0) {  // 不可预测的分支
            sum += arr[i];
        }
    }
    return sum;
}

// 优化：减少分支，使用位操作
int sum_even_fast(int arr[], int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        // 使用位操作，减少分支
        sum += (1 - (arr[i] & 1)) * arr[i];
    }
    return sum;
}

// 更好的优化：分离数据
int sum_even_separated(int arr[], int n) {
    int sum = 0;
    // 假设数据已分离，只包含偶数
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }
    return sum;
}

int main() {
    const int SIZE = 1000000;
    int *arr = (int *)malloc(SIZE * sizeof(int));
    
    // 随机数据（分支预测困难）
    srand(time(NULL));
    for (int i = 0; i < SIZE; i++) {
        arr[i] = rand() % 100;
    }
    
    clock_t start, end;
    
    start = clock();
    int result1 = sum_even_slow(arr, SIZE);
    end = clock();
    printf("慢版本: %d, 时间: %f 秒\n", 
           result1, ((double)(end - start)) / CLOCKS_PER_SEC);
    
    start = clock();
    int result2 = sum_even_fast(arr, SIZE);
    end = clock();
    printf("快版本: %d, 时间: %f 秒\n", 
           result2, ((double)(end - start)) / CLOCKS_PER_SEC);
    
    free(arr);
    return 0;
}
```

## 9. 内存池优化

### 减少malloc调用

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define POOL_SIZE 1024
#define BLOCK_SIZE 64

// 内存池
typedef struct {
    char pool[POOL_SIZE];
    int free_list[POOL_SIZE / BLOCK_SIZE];
    int free_count;
} MemoryPool;

MemoryPool* pool_create() {
    MemoryPool *pool = (MemoryPool *)malloc(sizeof(MemoryPool));
    pool->free_count = POOL_SIZE / BLOCK_SIZE;
    
    for (int i = 0; i < pool->free_count; i++) {
        pool->free_list[i] = i;
    }
    
    return pool;
}

void* pool_alloc(MemoryPool *pool) {
    if (pool->free_count > 0) {
        int index = pool->free_list[--pool->free_count];
        return pool->pool + (index * BLOCK_SIZE);
    }
    return NULL;
}

void pool_free(MemoryPool *pool, void *ptr) {
    if (ptr >= pool->pool && ptr < pool->pool + POOL_SIZE) {
        int index = ((char *)ptr - pool->pool) / BLOCK_SIZE;
        pool->free_list[pool->free_count++] = index;
    }
}

void pool_destroy(MemoryPool *pool) {
    free(pool);
}

int main() {
    MemoryPool *pool = pool_create();
    
    void *ptr1 = pool_alloc(pool);
    void *ptr2 = pool_alloc(pool);
    
    strcpy((char *)ptr1, "Hello");
    strcpy((char *)ptr2, "World");
    
    printf("%s %s\n", (char *)ptr1, (char *)ptr2);
    
    pool_free(pool, ptr1);
    pool_free(pool, ptr2);
    pool_destroy(pool);
    
    return 0;
}
```

## 10. 性能分析工具

### 使用gprof

```c
#include <stdio.h>
#include <time.h>
#include <unistd.h>

// 编译: gcc -pg -O2 program.c -o program
// 运行: ./program
// 分析: gprof program gmon.out > analysis.txt

void slow_function() {
    usleep(100000);  // 100ms
}

void fast_function() {
    // 快速函数
}

int main() {
    for (int i = 0; i < 10; i++) {
        slow_function();
        fast_function();
    }
    return 0;
}
```

## 性能优化原则

1. **测量优先**：先测量，再优化
2. **算法优化**：选择合适的数据结构和算法
3. **编译器优化**：使用-O2或-O3优化级别
4. **减少内存访问**：提高缓存命中率
5. **减少分支**：优化条件判断
6. **内联小函数**：减少函数调用开销
7. **预计算**：使用查找表替代计算
8. **内存池**：减少动态内存分配

## 练习

1. 对比不同循环展开方式对性能的影响
2. 实现一个缓存友好的矩阵乘法
3. 使用查找表优化三角函数计算
4. 实现一个高性能的内存分配器

