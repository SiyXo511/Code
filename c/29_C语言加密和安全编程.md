# C语言加密和安全编程

本教程将学习C语言中的加密和安全编程，包括OpenSSL基础和安全编程实践。

## 1. OpenSSL 基础

### 哈希函数

```c
#include <openssl/sha.h>
#include <openssl/md5.h>
#include <stdio.h>
#include <string.h>

void hash_example() {
    unsigned char digest[SHA256_DIGEST_LENGTH];
    char data[] = "Hello, OpenSSL!";
    
    // SHA256哈希
    SHA256_CTX ctx;
    SHA256_Init(&ctx);
    SHA256_Update(&ctx, data, strlen(data));
    SHA256_Final(digest, &ctx);
    
    printf("SHA256: ");
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        printf("%02x", digest[i]);
    }
    printf("\n");
    
    // MD5哈希
    unsigned char md5_digest[MD5_DIGEST_LENGTH];
    MD5((unsigned char *)data, strlen(data), md5_digest);
    
    printf("MD5: ");
    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {
        printf("%02x", md5_digest[i]);
    }
    printf("\n");
}

// 编译: gcc hash_example.c -o hash_example -lssl -lcrypto
```

### 对称加密（AES）

```c
#include <openssl/aes.h>
#include <openssl/rand.h>
#include <stdio.h>
#include <string.h>

void aes_encrypt_example() {
    unsigned char key[32];  // AES-256密钥
    unsigned char iv[16];   // 初始化向量
    unsigned char plaintext[] = "Hello, AES Encryption!";
    unsigned char ciphertext[128];
    unsigned char decrypted[128];
    
    // 生成随机密钥和IV
    RAND_bytes(key, 32);
    RAND_bytes(iv, 16);
    
    // 加密
    AES_KEY aes_key;
    AES_set_encrypt_key(key, 256, &aes_key);
    AES_cbc_encrypt(plaintext, ciphertext, strlen((char *)plaintext),
                    &aes_key, iv, AES_ENCRYPT);
    
    // 解密
    AES_set_decrypt_key(key, 256, &aes_key);
    AES_cbc_encrypt(ciphertext, decrypted, strlen((char *)plaintext),
                    &aes_key, iv, AES_DECRYPT);
    
    printf("原文: %s\n", plaintext);
    printf("解密: %s\n", decrypted);
}
```

### 非对称加密（RSA）

```c
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/err.h>
#include <stdio.h>
#include <string.h>

void rsa_example() {
    RSA *rsa = RSA_new();
    BIGNUM *bne = BN_new();
    unsigned char plaintext[] = "Hello, RSA!";
    unsigned char encrypted[256];
    unsigned char decrypted[256];
    
    // 生成RSA密钥对
    BN_set_word(bne, RSA_F4);
    RSA_generate_key_ex(rsa, 2048, bne, NULL);
    
    // 加密
    int encrypted_len = RSA_public_encrypt(strlen((char *)plaintext),
                                           plaintext, encrypted,
                                           rsa, RSA_PKCS1_PADDING);
    
    // 解密
    int decrypted_len = RSA_private_decrypt(encrypted_len, encrypted,
                                            decrypted, rsa,
                                            RSA_PKCS1_PADDING);
    
    decrypted[decrypted_len] = '\0';
    printf("解密: %s\n", decrypted);
    
    RSA_free(rsa);
    BN_free(bne);
}
```

## 2. 安全编程实践

### 缓冲区溢出防护

```c
#include <stdio.h>
#include <string.h>

// 不安全的函数
void unsafe_copy(char *dest, const char *src) {
    strcpy(dest, src);  // 危险：可能溢出
}

// 安全的函数
void safe_copy(char *dest, size_t dest_size, const char *src) {
    strncpy(dest, src, dest_size - 1);
    dest[dest_size - 1] = '\0';  // 确保字符串结束
}

// 使用strncpy
void safe_example() {
    char buffer[10];
    const char *input = "这是一个很长的字符串";
    
    // 安全复制
    safe_copy(buffer, sizeof(buffer), input);
    printf("安全复制: %s\n", buffer);
}
```

### 输入验证

```c
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <limits.h>

// 安全的整数输入
int safe_get_int(const char *input) {
    char *endptr;
    long value = strtol(input, &endptr, 10);
    
    // 检查转换是否成功
    if (*endptr != '\0' && *endptr != '\n') {
        return -1;  // 无效输入
    }
    
    // 检查范围
    if (value < INT_MIN || value > INT_MAX) {
        return -1;  // 超出范围
    }
    
    return (int)value;
}

// 验证字符串长度
int validate_string(const char *str, size_t max_len) {
    if (str == NULL) {
        return 0;
    }
    
    size_t len = strlen(str);
    if (len > max_len) {
        return 0;  // 超出最大长度
    }
    
    return 1;
}
```

### 内存安全

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 安全的字符串分配
char* safe_strdup(const char *src) {
    if (src == NULL) {
        return NULL;
    }
    
    size_t len = strlen(src);
    char *dest = (char *)malloc(len + 1);
    
    if (dest == NULL) {
        return NULL;  // 内存分配失败
    }
    
    strcpy(dest, src);
    return dest;
}

// 安全的字符串连接
char* safe_strcat(char *dest, size_t dest_size,
                   const char *src) {
    if (dest == NULL || src == NULL) {
        return NULL;
    }
    
    size_t dest_len = strlen(dest);
    size_t src_len = strlen(src);
    
    if (dest_len + src_len >= dest_size) {
        return NULL;  // 缓冲区太小
    }
    
    strcat(dest, src);
    return dest;
}
```

### 密码处理

```c
#include <stdio.h>
#include <string.h>
#include <openssl/rand.h>

// 生成随机密码
void generate_password(char *password, size_t length) {
    const char charset[] = "abcdefghijklmnopqrstuvwxyz"
                           "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                           "0123456789!@#$%^&*";
    
    RAND_bytes((unsigned char *)password, length);
    
    for (size_t i = 0; i < length; i++) {
        password[i] = charset[password[i] % (sizeof(charset) - 1)];
    }
    password[length] = '\0';
}

// 安全比较（防止时序攻击）
int secure_compare(const char *a, const char *b, size_t len) {
    unsigned char result = 0;
    
    for (size_t i = 0; i < len; i++) {
        result |= a[i] ^ b[i];
    }
    
    return result == 0;
}
```

### 敏感数据清理

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// 安全清理内存（防止敏感数据残留）
void secure_memset(void *ptr, int value, size_t len) {
    volatile unsigned char *p = (volatile unsigned char *)ptr;
    while (len--) {
        *p++ = (unsigned char)value;
    }
}

// 安全释放包含敏感数据的内存
void secure_free(void *ptr, size_t len) {
    if (ptr != NULL) {
        secure_memset(ptr, 0, len);
        free(ptr);
    }
}

void sensitive_data_example() {
    char *password = (char *)malloc(100);
    strcpy(password, "my_secret_password");
    
    // 使用密码...
    
    // 安全清理
    secure_free(password, 100);
}
```

## 3. 常见安全漏洞

### SQL注入防护

```c
#include <stdio.h>
#include <sqlite3.h>
#include <string.h>

// 不安全的查询（容易SQL注入）
void unsafe_query(sqlite3 *db, const char *username) {
    char sql[256];
    sprintf(sql, "SELECT * FROM users WHERE name = '%s'", username);
    // 危险：如果username包含 ' OR '1'='1 会导致SQL注入
    sqlite3_exec(db, sql, 0, 0, 0);
}

// 安全的参数化查询
void safe_query(sqlite3 *db, const char *username) {
    sqlite3_stmt *stmt;
    const char *sql = "SELECT * FROM users WHERE name = ?";
    
    sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
    sqlite3_bind_text(stmt, 1, username, -1, SQLITE_STATIC);
    
    while (sqlite3_step(stmt) == SQLITE_ROW) {
        // 处理结果...
    }
    
    sqlite3_finalize(stmt);
}
```

### 格式化字符串漏洞

```c
#include <stdio.h>

// 不安全的格式化
void unsafe_format(const char *user_input) {
    printf(user_input);  // 危险：格式化字符串漏洞
}

// 安全的格式化
void safe_format(const char *user_input) {
    printf("%s", user_input);  // 安全：使用格式说明符
}
```

## 4. 安全编程最佳实践

### 1. 始终验证输入
```c
int validate_input(const char *input, size_t max_len) {
    if (input == NULL) return 0;
    if (strlen(input) > max_len) return 0;
    // 更多验证...
    return 1;
}
```

### 2. 使用安全的字符串函数
```c
// 使用 strncpy, strncat, snprintf 等
char buffer[100];
snprintf(buffer, sizeof(buffer), "%s", user_input);
```

### 3. 检查返回值
```c
void *ptr = malloc(size);
if (ptr == NULL) {
    // 处理错误
    return;
}
```

### 4. 最小权限原则
```c
// 只请求必要的权限
// 及时释放不需要的资源
```

## 练习

1. 实现一个密码管理器（使用AES加密）
2. 创建一个安全的文件加密工具
3. 实现数字签名验证
4. 编写一个安全的网络通信程序

