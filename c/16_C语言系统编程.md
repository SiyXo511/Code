# C语言系统编程

本教程将学习C语言中的系统编程，包括进程、线程、信号、文件系统等内容。

## 1. 进程管理

### 创建进程

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();
    
    if (pid < 0) {
        // 创建进程失败
        perror("fork失败");
        exit(EXIT_FAILURE);
    } else if (pid == 0) {
        // 子进程
        printf("这是子进程，PID: %d\n", getpid());
        printf("父进程PID: %d\n", getppid());
        exit(EXIT_SUCCESS);
    } else {
        // 父进程
        printf("这是父进程，PID: %d\n", getpid());
        printf("子进程PID: %d\n", pid);
        
        // 等待子进程结束
        int status;
        wait(&status);
        printf("子进程已结束\n");
    }
    
    return 0;
}
```

### exec函数族

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();
    
    if (pid == 0) {
        // 子进程：执行新程序
        printf("子进程：准备执行ls命令\n");
        
        // execl: 参数列表
        execl("/bin/ls", "ls", "-l", NULL);
        
        // 如果exec成功，不会执行到这里
        perror("exec失败");
        exit(EXIT_FAILURE);
    } else {
        // 父进程等待
        wait(NULL);
        printf("父进程：ls命令执行完成\n");
    }
    
    return 0;
}
```

## 2. 进程通信

### 管道（Pipe）

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    int pipefd[2];
    char buffer[100];
    
    // 创建管道
    if (pipe(pipefd) == -1) {
        perror("pipe创建失败");
        exit(EXIT_FAILURE);
    }
    
    pid_t pid = fork();
    
    if (pid == 0) {
        // 子进程：写入管道
        close(pipefd[0]);  // 关闭读端
        
        const char *message = "Hello from child process!";
        write(pipefd[1], message, strlen(message) + 1);
        close(pipefd[1]);
        
        exit(EXIT_SUCCESS);
    } else {
        // 父进程：从管道读取
        close(pipefd[1]);  // 关闭写端
        
        read(pipefd[0], buffer, sizeof(buffer));
        printf("父进程收到消息: %s\n", buffer);
        close(pipefd[0]);
        
        wait(NULL);
    }
    
    return 0;
}
```

### 共享内存

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

#define SHM_SIZE 1024

int main() {
    // 创建共享内存
    key_t key = ftok("/tmp", 'R');
    int shmid = shmget(key, SHM_SIZE, IPC_CREAT | 0666);
    
    if (shmid == -1) {
        perror("共享内存创建失败");
        exit(EXIT_FAILURE);
    }
    
    // 附加到共享内存
    char *shm = (char *)shmat(shmid, NULL, 0);
    
    if (shm == (char *)-1) {
        perror("共享内存附加失败");
        exit(EXIT_FAILURE);
    }
    
    pid_t pid = fork();
    
    if (pid == 0) {
        // 子进程：写入共享内存
        strcpy(shm, "Hello from shared memory!");
        shmdt(shm);  // 分离共享内存
        exit(EXIT_SUCCESS);
    } else {
        // 父进程：读取共享内存
        wait(NULL);
        printf("从共享内存读取: %s\n", shm);
        
        shmdt(shm);  // 分离共享内存
        shmctl(shmid, IPC_RMID, NULL);  // 删除共享内存
    }
    
    return 0;
}
```

## 3. 信号处理

### 信号基础

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>

volatile sig_atomic_t keep_running = 1;

void signal_handler(int sig) {
    switch (sig) {
        case SIGINT:
            printf("\n收到SIGINT信号（Ctrl+C）\n");
            keep_running = 0;
            break;
        case SIGTERM:
            printf("\n收到SIGTERM信号\n");
            keep_running = 0;
            break;
        case SIGUSR1:
            printf("收到SIGUSR1信号\n");
            break;
        default:
            printf("收到未知信号: %d\n", sig);
            break;
    }
}

int main() {
    // 注册信号处理函数
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    signal(SIGUSR1, signal_handler);
    
    printf("进程PID: %d\n", getpid());
    printf("按Ctrl+C退出，或使用 kill -SIGUSR1 %d 发送信号\n", getpid());
    
    while (keep_running) {
        printf("运行中...\n");
        sleep(1);
    }
    
    printf("程序正常退出\n");
    return 0;
}
```

### 发送信号

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>

int main(int argc, char *argv[]) {
    if (argc != 3) {
        printf("用法: %s <PID> <信号>\n", argv[0]);
        printf("信号: 2=SIGINT, 15=SIGTERM, 10=SIGUSR1\n");
        return 1;
    }
    
    pid_t pid = atoi(argv[1]);
    int sig = atoi(argv[2]);
    
    if (kill(pid, sig) == -1) {
        perror("发送信号失败");
        return 1;
    }
    
    printf("信号 %d 已发送到进程 %d\n", sig, pid);
    return 0;
}
```

## 4. 文件系统操作

### 文件和目录操作

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <dirent.h>
#include <string.h>

// 文件信息
void file_info(const char *filename) {
    struct stat st;
    
    if (stat(filename, &st) == -1) {
        perror("stat失败");
        return;
    }
    
    printf("文件: %s\n", filename);
    printf("大小: %ld 字节\n", st.st_size);
    printf("inode: %lu\n", st.st_ino);
    printf("权限: %o\n", st.st_mode & 0777);
    printf("用户ID: %d\n", st.st_uid);
    printf("组ID: %d\n", st.st_gid);
}

// 列出目录内容
void list_directory(const char *dirname) {
    DIR *dir = opendir(dirname);
    if (dir == NULL) {
        perror("无法打开目录");
        return;
    }
    
    struct dirent *entry;
    printf("目录内容: %s\n", dirname);
    printf("------------------------\n");
    
    while ((entry = readdir(dir)) != NULL) {
        printf("%s\n", entry->d_name);
    }
    
    closedir(dir);
}

// 创建符号链接
void create_symlink(const char *target, const char *linkname) {
    if (symlink(target, linkname) == -1) {
        perror("创建符号链接失败");
    } else {
        printf("符号链接已创建: %s -> %s\n", linkname, target);
    }
}

int main() {
    file_info("test.txt");
    list_directory(".");
    create_symlink("test.txt", "test_link");
    
    return 0;
}
```

### 文件锁定

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/file.h>

int main() {
    int fd = open("test.txt", O_RDWR | O_CREAT, 0644);
    if (fd == -1) {
        perror("打开文件失败");
        return 1;
    }
    
    // 尝试加锁
    if (flock(fd, LOCK_EX | LOCK_NB) == -1) {
        perror("文件已被锁定");
        close(fd);
        return 1;
    }
    
    printf("文件已锁定，写入数据...\n");
    write(fd, "Locked content\n", 16);
    
    sleep(5);  // 保持锁定5秒
    
    // 解锁
    flock(fd, LOCK_UN);
    printf("文件已解锁\n");
    
    close(fd);
    return 0;
}
```

## 5. 系统调用

### 基本的系统调用

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>

// 使用系统调用读写文件
void syscall_file_ops() {
    int fd;
    char buffer[100];
    
    // 打开文件（系统调用）
    fd = open("syscall_test.txt", O_CREAT | O_WRONLY | O_TRUNC, 0644);
    if (fd == -1) {
        perror("打开文件失败");
        return;
    }
    
    // 写入文件（系统调用）
    const char *message = "Hello from system call!\n";
    ssize_t written = write(fd, message, strlen(message));
    if (written == -1) {
        perror("写入失败");
    } else {
        printf("写入 %ld 字节\n", written);
    }
    
    close(fd);
    
    // 读取文件（系统调用）
    fd = open("syscall_test.txt", O_RDONLY);
    if (fd == -1) {
        perror("打开文件失败");
        return;
    }
    
    ssize_t read_bytes = read(fd, buffer, sizeof(buffer) - 1);
    if (read_bytes == -1) {
        perror("读取失败");
    } else {
        buffer[read_bytes] = '\0';
        printf("读取内容: %s", buffer);
    }
    
    close(fd);
}

int main() {
    syscall_file_ops();
    
    // 获取系统信息
    printf("\n系统信息:\n");
    printf("进程ID: %d\n", getpid());
    printf("父进程ID: %d\n", getppid());
    printf("用户ID: %d\n", getuid());
    printf("有效用户ID: %d\n", geteuid());
    
    return 0;
}
```

## 6. 进程环境

### 环境变量

```c
#include <stdio.h>
#include <stdlib.h>

void print_environment() {
    extern char **environ;
    char **env = environ;
    
    printf("环境变量:\n");
    while (*env != NULL) {
        printf("  %s\n", *env);
        env++;
    }
}

void get_environment_var() {
    const char *path = getenv("PATH");
    if (path != NULL) {
        printf("PATH: %s\n", path);
    }
    
    const char *home = getenv("HOME");
    if (home != NULL) {
        printf("HOME: %s\n", home);
    }
}

void set_environment_var() {
    // 设置环境变量（仅对当前进程有效）
    if (setenv("MY_VAR", "my_value", 1) == 0) {
        printf("环境变量已设置: MY_VAR=%s\n", getenv("MY_VAR"));
    }
    
    // 删除环境变量
    unsetenv("MY_VAR");
    if (getenv("MY_VAR") == NULL) {
        printf("环境变量已删除\n");
    }
}

int main() {
    get_environment_var();
    set_environment_var();
    
    return 0;
}
```

## 7. 综合示例

### 守护进程（Daemon）

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>
#include <syslog.h>

void daemonize() {
    pid_t pid;
    
    // 1. 创建子进程
    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    
    // 2. 父进程退出
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }
    
    // 3. 创建新会话
    if (setsid() < 0) {
        exit(EXIT_FAILURE);
    }
    
    // 4. 再次fork
    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }
    
    // 5. 更改工作目录
    chdir("/");
    
    // 6. 关闭文件描述符
    for (int i = 0; i < 3; i++) {
        close(i);
    }
    
    // 7. 重定向标准输入输出错误
    open("/dev/null", O_RDWR);  // stdin
    dup(0);  // stdout
    dup(0);  // stderr
}

int main() {
    daemonize();
    
    // 打开系统日志
    openlog("mydaemon", LOG_PID, LOG_DAEMON);
    syslog(LOG_INFO, "守护进程已启动");
    
    // 守护进程主循环
    while (1) {
        syslog(LOG_INFO, "守护进程运行中...");
        sleep(10);
    }
    
    closelog();
    return 0;
}
```

## 练习

1. 实现一个进程监控程序，监控子进程的状态
2. 创建父子进程通过管道通信的程序
3. 实现一个简单的守护进程
4. 编写程序，使用信号实现进程间通信

## 注意事项

1. **错误检查**：所有系统调用都要检查返回值
2. **资源清理**：确保释放所有分配的资源
3. **信号安全**：信号处理函数中只能使用异步信号安全的函数
4. **权限**：某些操作需要特定权限
5. **平台差异**：不同操作系统API可能有差异

