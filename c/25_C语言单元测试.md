# C语言单元测试

本教程将学习C语言中的单元测试，包括Unity、Check等测试框架的使用。

## 1. Unity 测试框架

### Unity 基础

```c
// test_example.c
#include "unity.h"

// 被测试的函数
int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}

// 测试用例
void test_add(void) {
    TEST_ASSERT_EQUAL(5, add(2, 3));
    TEST_ASSERT_EQUAL(0, add(-1, 1));
    TEST_ASSERT_EQUAL(100, add(50, 50));
}

void test_multiply(void) {
    TEST_ASSERT_EQUAL(6, multiply(2, 3));
    TEST_ASSERT_EQUAL(0, multiply(0, 100));
    TEST_ASSERT_EQUAL(-10, multiply(-2, 5));
}

// 测试运行器
int main(void) {
    UNITY_BEGIN();
    
    RUN_TEST(test_add);
    RUN_TEST(test_multiply);
    
    return UNITY_END();
}

// 编译: gcc test_example.c unity.c -o test_example
// 运行: ./test_example
```

### Unity 断言方法

```c
#include "unity.h"

void test_assertions(void) {
    int x = 10;
    int y = 20;
    int arr1[] = {1, 2, 3};
    int arr2[] = {1, 2, 3};
    
    // 相等断言
    TEST_ASSERT_EQUAL(10, x);
    TEST_ASSERT_EQUAL_INT(10, x);
    TEST_ASSERT_EQUAL_INT8(10, x);
    TEST_ASSERT_EQUAL_INT16(10, x);
    TEST_ASSERT_EQUAL_INT32(10, x);
    
    // 不相等断言
    TEST_ASSERT_NOT_EQUAL(5, x);
    
    // 真/假断言
    TEST_ASSERT_TRUE(x > 5);
    TEST_ASSERT_FALSE(x < 5);
    
    // 空指针断言
    int *ptr = NULL;
    TEST_ASSERT_NULL(ptr);
    ptr = &x;
    TEST_ASSERT_NOT_NULL(ptr);
    
    // 数组比较
    TEST_ASSERT_EQUAL_INT_ARRAY(arr1, arr2, 3);
    
    // 字符串比较
    TEST_ASSERT_EQUAL_STRING("Hello", "Hello");
    TEST_ASSERT_EQUAL_STRING_LEN("Hello", "Hello World", 5);
    
    // 浮点数比较（带误差）
    float f1 = 3.14159f;
    float f2 = 3.14160f;
    TEST_ASSERT_FLOAT_WITHIN(0.0001f, f1, f2);
}

int main(void) {
    UNITY_BEGIN();
    RUN_TEST(test_assertions);
    return UNITY_END();
}
```

### 测试夹具（Setup/Teardown）

```c
#include "unity.h"
#include <stdlib.h>

// 测试数据
static int *test_array = NULL;
static int array_size = 0;

// 测试前设置
void setUp(void) {
    array_size = 10;
    test_array = (int *)malloc(array_size * sizeof(int));
    for (int i = 0; i < array_size; i++) {
        test_array[i] = i;
    }
}

// 测试后清理
void tearDown(void) {
    if (test_array != NULL) {
        free(test_array);
        test_array = NULL;
    }
    array_size = 0;
}

void test_array_sum(void) {
    int sum = 0;
    for (int i = 0; i < array_size; i++) {
        sum += test_array[i];
    }
    TEST_ASSERT_EQUAL(45, sum);  // 0+1+2+...+9 = 45
}

void test_array_access(void) {
    TEST_ASSERT_EQUAL(0, test_array[0]);
    TEST_ASSERT_EQUAL(5, test_array[5]);
    TEST_ASSERT_EQUAL(9, test_array[9]);
}

int main(void) {
    UNITY_BEGIN();
    RUN_TEST(test_array_sum);
    RUN_TEST(test_array_access);
    return UNITY_END();
}
```

## 2. Check 测试框架

### Check 基础

```c
// test_check.c
#include <check.h>
#include <stdlib.h>

// 被测试的函数
int divide(int a, int b) {
    if (b == 0) {
        return -1;  // 错误
    }
    return a / b;
}

// 测试用例
START_TEST(test_divide_normal) {
    ck_assert_int_eq(5, divide(10, 2));
    ck_assert_int_eq(3, divide(9, 3));
}
END_TEST

START_TEST(test_divide_by_zero) {
    ck_assert_int_eq(-1, divide(10, 0));
}
END_TEST

// 测试套件
Suite* math_suite(void) {
    Suite *s;
    TCase *tc_core;
    
    s = suite_create("Math");
    tc_core = tcase_create("Core");
    
    tcase_add_test(tc_core, test_divide_normal);
    tcase_add_test(tc_core, test_divide_by_zero);
    
    suite_add_tcase(s, tc_core);
    return s;
}

int main(void) {
    int number_failed;
    Suite *s;
    SRunner *sr;
    
    s = math_suite();
    sr = srunner_create(s);
    
    srunner_run_all(sr, CK_NORMAL);
    number_failed = srunner_ntests_failed(sr);
    srunner_free(sr);
    
    return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}

// 编译: gcc test_check.c -lcheck -o test_check
// 运行: ./test_check
```

### Check 断言方法

```c
#include <check.h>

START_TEST(test_assertions) {
    int x = 10;
    int y = 20;
    
    // 相等断言
    ck_assert_int_eq(10, x);
    ck_assert_int_ne(5, x);
    
    // 比较断言
    ck_assert_int_lt(x, y);  // less than
    ck_assert_int_le(x, x);  // less or equal
    ck_assert_int_gt(y, x);  // greater than
    ck_assert_int_ge(y, y);  // greater or equal
    
    // 指针断言
    int *ptr = NULL;
    ck_assert_ptr_null(ptr);
    ptr = &x;
    ck_assert_ptr_nonnull(ptr);
    ck_assert_ptr_eq(&x, ptr);
    
    // 字符串断言
    ck_assert_str_eq("Hello", "Hello");
    ck_assert_str_ne("Hello", "World");
    
    // 消息断言（带自定义消息）
    ck_assert_msg(x > 5, "x应该大于5");
}
END_TEST
```

## 3. 自定义测试框架

### 简单的测试框架实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 测试结果
typedef struct {
    const char *name;
    int passed;
    int failed;
} TestResult;

static TestResult test_result = {NULL, 0, 0};

// 测试宏
#define TEST(name) \
    void test_##name(void); \
    void test_##name(void)

#define ASSERT(condition, message) \
    do { \
        if (!(condition)) { \
            printf("  [失败] %s\n", message); \
            test_result.failed++; \
            return; \
        } \
    } while(0)

#define ASSERT_EQ(expected, actual) \
    ASSERT((expected) == (actual), \
           #expected " == " #actual " 失败")

#define ASSERT_NE(expected, actual) \
    ASSERT((expected) != (actual), \
           #expected " != " #actual " 失败")

#define RUN_TEST(test_func) \
    do { \
        printf("运行测试: %s\n", #test_func); \
        test_result.name = #test_func; \
        test_func(); \
        if (test_result.failed == 0) { \
            printf("  [通过]\n"); \
            test_result.passed++; \
        } \
        test_result.failed = 0; \
    } while(0)

// 测试用例示例
TEST(add_test) {
    int result = 2 + 3;
    ASSERT_EQ(5, result);
}

TEST(multiply_test) {
    int result = 2 * 3;
    ASSERT_EQ(6, result);
}

int main(void) {
    printf("=== 测试开始 ===\n\n");
    
    RUN_TEST(test_add_test);
    RUN_TEST(test_multiply_test);
    
    printf("\n=== 测试结果 ===\n");
    printf("通过: %d\n", test_result.passed);
    printf("失败: %d\n", test_result.failed);
    
    return (test_result.failed > 0) ? 1 : 0;
}
```

## 4. 测试驱动开发（TDD）

### TDD 示例

```c
// calculator.h
#ifndef CALCULATOR_H
#define CALCULATOR_H

int add(int a, int b);
int subtract(int a, int b);
int multiply(int a, int b);
double divide(double a, double b);

#endif

// calculator.c
#include "calculator.h"

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

double divide(double a, double b) {
    if (b == 0.0) {
        return 0.0;  // 错误处理
    }
    return a / b;
}

// test_calculator.c
#include "unity.h"
#include "calculator.h"

void test_add(void) {
    TEST_ASSERT_EQUAL(5, add(2, 3));
    TEST_ASSERT_EQUAL(0, add(-1, 1));
}

void test_subtract(void) {
    TEST_ASSERT_EQUAL(1, subtract(3, 2));
    TEST_ASSERT_EQUAL(-2, subtract(1, 3));
}

void test_multiply(void) {
    TEST_ASSERT_EQUAL(6, multiply(2, 3));
    TEST_ASSERT_EQUAL(0, multiply(0, 100));
}

void test_divide(void) {
    TEST_ASSERT_FLOAT_WITHIN(0.001, 2.0, divide(10.0, 5.0));
    TEST_ASSERT_FLOAT_WITHIN(0.001, 0.0, divide(10.0, 0.0));
}

int main(void) {
    UNITY_BEGIN();
    RUN_TEST(test_add);
    RUN_TEST(test_subtract);
    RUN_TEST(test_multiply);
    RUN_TEST(test_divide);
    return UNITY_END();
}
```

## 5. 模拟（Mock）和存根（Stub）

### 函数模拟

```c
#include <stdio.h>
#include <stdlib.h>

// 原始函数（需要模拟）
int read_file(const char *filename) {
    // 实际文件读取...
    return 0;
}

// 模拟函数指针
static int (*mock_read_file)(const char *) = NULL;

// 可替换的读取函数
int read_file_wrapper(const char *filename) {
    if (mock_read_file != NULL) {
        return mock_read_file(filename);
    }
    return read_file(filename);
}

// 测试用的模拟函数
int mock_read_file_success(const char *filename) {
    (void)filename;  // 未使用参数
    return 1;  // 模拟成功
}

int mock_read_file_failure(const char *filename) {
    (void)filename;
    return 0;  // 模拟失败
}

void test_with_mock(void) {
    // 使用模拟函数
    mock_read_file = mock_read_file_success;
    int result = read_file_wrapper("test.txt");
    printf("模拟成功结果: %d\n", result);
    
    mock_read_file = mock_read_file_failure;
    result = read_file_wrapper("test.txt");
    printf("模拟失败结果: %d\n", result);
    
    // 恢复原始函数
    mock_read_file = NULL;
}

int main(void) {
    test_with_mock();
    return 0;
}
```

## 6. 测试覆盖率

### 使用gcov

```c
// coverage_example.c
#include <stdio.h>

int function1(int x) {
    if (x > 0) {
        return x * 2;
    } else {
        return 0;
    }
}

int function2(int x) {
    return x + 10;
}

int main(void) {
    printf("%d\n", function1(5));
    printf("%d\n", function2(3));
    return 0;
}

// 编译: gcc --coverage coverage_example.c -o coverage_example
// 运行: ./coverage_example
// 生成报告: gcov coverage_example.c
// 查看: cat coverage_example.c.gcov
```

## 7. 集成测试

### 模块集成测试

```c
#include "unity.h"
#include "module1.h"
#include "module2.h"

void test_module_integration(void) {
    // 测试模块1和模块2的集成
    int result1 = module1_function(10);
    int result2 = module2_function(result1);
    
    TEST_ASSERT_EQUAL(20, result2);
}

void test_data_flow(void) {
    // 测试数据在模块间的流动
    Data data = {0};
    module1_process(&data);
    module2_process(&data);
    
    TEST_ASSERT_EQUAL(100, data.value);
}

int main(void) {
    UNITY_BEGIN();
    RUN_TEST(test_module_integration);
    RUN_TEST(test_data_flow);
    return UNITY_END();
}
```

## 8. 性能测试

### 基准测试

```c
#include <stdio.h>
#include <time.h>

void benchmark_function(void) {
    clock_t start = clock();
    
    // 执行被测试的函数
    for (int i = 0; i < 1000000; i++) {
        // 函数调用
    }
    
    clock_t end = clock();
    double cpu_time = ((double)(end - start)) / CLOCKS_PER_SEC;
    
    printf("执行时间: %.6f 秒\n", cpu_time);
}

// 使用宏简化基准测试
#define BENCHMARK(func, iterations) \
    do { \
        clock_t start = clock(); \
        for (int i = 0; i < iterations; i++) { \
            func(); \
        } \
        clock_t end = clock(); \
        double time = ((double)(end - start)) / CLOCKS_PER_SEC; \
        printf("%s: %.6f 秒\n", #func, time); \
    } while(0)

int main(void) {
    BENCHMARK(function1, 1000000);
    BENCHMARK(function2, 1000000);
    return 0;
}
```

## 练习

1. 为你的项目编写完整的单元测试套件
2. 实现一个测试框架，支持参数化测试
3. 使用gcov分析测试覆盖率
4. 编写集成测试和性能测试

