# C语言数据库编程

本教程将学习C语言中的数据库编程，包括SQLite和MySQL的使用。

## 1. SQLite 数据库

### SQLite 基础操作

```c
#include <stdio.h>
#include <sqlite3.h>
#include <stdlib.h>

int callback(void *data, int argc, char **argv, char **azColName) {
    int i;
    printf("%s: ", (const char *)data);
    
    for (i = 0; i < argc; i++) {
        printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
    }
    printf("\n");
    return 0;
}

void sqlite_basic() {
    sqlite3 *db;
    char *err_msg = 0;
    int rc;
    
    // 打开数据库
    rc = sqlite3_open("test.db", &db);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "无法打开数据库: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        return;
    }
    
    // 创建表
    const char *sql = "CREATE TABLE IF NOT EXISTS users("
                      "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                      "name TEXT NOT NULL,"
                      "age INTEGER,"
                      "email TEXT);";
    
    rc = sqlite3_exec(db, sql, 0, 0, &err_msg);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL错误: %s\n", err_msg);
        sqlite3_free(err_msg);
    }
    
    // 插入数据
    sql = "INSERT INTO users (name, age, email) VALUES "
          "('张三', 25, 'zhangsan@example.com'),"
          "('李四', 30, 'lisi@example.com');";
    
    rc = sqlite3_exec(db, sql, 0, 0, &err_msg);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL错误: %s\n", err_msg);
        sqlite3_free(err_msg);
    }
    
    // 查询数据
    sql = "SELECT * FROM users;";
    const char *data = "回调函数调用";
    
    rc = sqlite3_exec(db, sql, callback, (void *)data, &err_msg);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL错误: %s\n", err_msg);
        sqlite3_free(err_msg);
    }
    
    sqlite3_close(db);
}

// 编译: gcc sqlite_example.c -o sqlite_example -lsqlite3
```

### SQLite 参数化查询

```c
#include <stdio.h>
#include <sqlite3.h>
#include <stdlib.h>

void sqlite_prepared_statement() {
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    
    rc = sqlite3_open("test.db", &db);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "无法打开数据库: %s\n", sqlite3_errmsg(db));
        return;
    }
    
    // 准备语句
    const char *sql = "INSERT INTO users (name, age, email) VALUES (?, ?, ?);";
    rc = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
    
    if (rc != SQLITE_OK) {
        fprintf(stderr, "准备语句失败: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        return;
    }
    
    // 绑定参数
    sqlite3_bind_text(stmt, 1, "王五", -1, SQLITE_STATIC);
    sqlite3_bind_int(stmt, 2, 28);
    sqlite3_bind_text(stmt, 3, "wangwu@example.com", -1, SQLITE_STATIC);
    
    // 执行
    rc = sqlite3_step(stmt);
    if (rc != SQLITE_DONE) {
        fprintf(stderr, "执行失败: %s\n", sqlite3_errmsg(db));
    } else {
        printf("插入成功，ID: %lld\n", sqlite3_last_insert_rowid(db));
    }
    
    // 重置语句，可以再次使用
    sqlite3_reset(stmt);
    
    // 再次绑定不同的值
    sqlite3_bind_text(stmt, 1, "赵六", -1, SQLITE_STATIC);
    sqlite3_bind_int(stmt, 2, 35);
    sqlite3_bind_text(stmt, 3, "zhaoliu@example.com", -1, SQLITE_STATIC);
    sqlite3_step(stmt);
    
    sqlite3_finalize(stmt);
    sqlite3_close(db);
}
```

### SQLite 查询结果处理

```c
#include <stdio.h>
#include <sqlite3.h>
#include <stdlib.h>

void sqlite_query_results() {
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    
    rc = sqlite3_open("test.db", &db);
    if (rc != SQLITE_OK) {
        return;
    }
    
    const char *sql = "SELECT id, name, age, email FROM users WHERE age > ?;";
    rc = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
    
    if (rc == SQLITE_OK) {
        // 绑定参数
        sqlite3_bind_int(stmt, 1, 25);
        
        // 执行查询
        while ((rc = sqlite3_step(stmt)) == SQLITE_ROW) {
            int id = sqlite3_column_int(stmt, 0);
            const char *name = (const char *)sqlite3_column_text(stmt, 1);
            int age = sqlite3_column_int(stmt, 2);
            const char *email = (const char *)sqlite3_column_text(stmt, 3);
            
            printf("ID: %d, 姓名: %s, 年龄: %d, 邮箱: %s\n",
                   id, name, age, email);
        }
    }
    
    sqlite3_finalize(stmt);
    sqlite3_close(db);
}
```

## 2. MySQL C API

### MySQL 连接和基本操作

```c
#include <stdio.h>
#include <stdlib.h>
#include <mysql/mysql.h>

void mysql_basic() {
    MYSQL *conn;
    MYSQL_RES *res;
    MYSQL_ROW row;
    
    // 初始化连接
    conn = mysql_init(NULL);
    if (conn == NULL) {
        fprintf(stderr, "mysql_init失败\n");
        return;
    }
    
    // 连接到数据库
    if (mysql_real_connect(conn, "localhost", "user", "password",
                          "database", 0, NULL, 0) == NULL) {
        fprintf(stderr, "连接失败: %s\n", mysql_error(conn));
        mysql_close(conn);
        return;
    }
    
    // 执行查询
    if (mysql_query(conn, "SELECT * FROM users")) {
        fprintf(stderr, "查询失败: %s\n", mysql_error(conn));
        mysql_close(conn);
        return;
    }
    
    // 获取结果
    res = mysql_use_result(conn);
    
    // 打印列名
    MYSQL_FIELD *field;
    while ((field = mysql_fetch_field(res))) {
        printf("%s\t", field->name);
    }
    printf("\n");
    
    // 打印数据
    while ((row = mysql_fetch_row(res)) != NULL) {
        for (int i = 0; i < mysql_num_fields(res); i++) {
            printf("%s\t", row[i] ? row[i] : "NULL");
        }
        printf("\n");
    }
    
    mysql_free_result(res);
    mysql_close(conn);
}

// 编译: gcc mysql_example.c -o mysql_example -lmysqlclient
```

### MySQL 参数化查询

```c
#include <stdio.h>
#include <mysql/mysql.h>

void mysql_prepared_statement() {
    MYSQL *conn;
    MYSQL_STMT *stmt;
    MYSQL_BIND bind[3];
    
    char name[50] = "张三";
    int age = 25;
    char email[100] = "zhangsan@example.com";
    
    unsigned long name_length = strlen(name);
    unsigned long email_length = strlen(email);
    
    conn = mysql_init(NULL);
    mysql_real_connect(conn, "localhost", "user", "password",
                      "database", 0, NULL, 0);
    
    // 准备语句
    const char *sql = "INSERT INTO users (name, age, email) VALUES (?, ?, ?)";
    stmt = mysql_stmt_init(conn);
    mysql_stmt_prepare(stmt, sql, strlen(sql));
    
    // 绑定参数
    memset(bind, 0, sizeof(bind));
    
    bind[0].buffer_type = MYSQL_TYPE_STRING;
    bind[0].buffer = name;
    bind[0].buffer_length = sizeof(name);
    bind[0].length = &name_length;
    
    bind[1].buffer_type = MYSQL_TYPE_LONG;
    bind[1].buffer = &age;
    
    bind[2].buffer_type = MYSQL_TYPE_STRING;
    bind[2].buffer = email;
    bind[2].buffer_length = sizeof(email);
    bind[2].length = &email_length;
    
    mysql_stmt_bind_param(stmt, bind);
    
    // 执行
    if (mysql_stmt_execute(stmt)) {
        fprintf(stderr, "执行失败: %s\n", mysql_stmt_error(stmt));
    } else {
        printf("插入成功\n");
    }
    
    mysql_stmt_close(stmt);
    mysql_close(conn);
}
```

## 3. 数据库封装

### 简单的数据库封装

```c
#include <stdio.h>
#include <sqlite3.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    sqlite3 *db;
} Database;

Database* db_open(const char *filename) {
    Database *db = (Database *)malloc(sizeof(Database));
    int rc = sqlite3_open(filename, &db->db);
    
    if (rc != SQLITE_OK) {
        fprintf(stderr, "无法打开数据库: %s\n", sqlite3_errmsg(db->db));
        free(db);
        return NULL;
    }
    
    return db;
}

void db_close(Database *db) {
    if (db != NULL) {
        sqlite3_close(db->db);
        free(db);
    }
}

int db_execute(Database *db, const char *sql) {
    char *err_msg = 0;
    int rc = sqlite3_exec(db->db, sql, 0, 0, &err_msg);
    
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL错误: %s\n", err_msg);
        sqlite3_free(err_msg);
        return -1;
    }
    
    return 0;
}

int db_query(Database *db, const char *sql,
             int (*callback)(void *, int, char **, char **),
             void *data) {
    char *err_msg = 0;
    int rc = sqlite3_exec(db->db, sql, callback, data, &err_msg);
    
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL错误: %s\n", err_msg);
        sqlite3_free(err_msg);
        return -1;
    }
    
    return 0;
}

int main() {
    Database *db = db_open("test.db");
    
    if (db != NULL) {
        // 创建表
        db_execute(db, "CREATE TABLE IF NOT EXISTS users("
                      "id INTEGER PRIMARY KEY,"
                      "name TEXT,"
                      "age INTEGER);");
        
        // 插入数据
        db_execute(db, "INSERT INTO users (name, age) VALUES "
                      "('张三', 25), ('李四', 30);");
        
        // 查询数据
        int callback(void *data, int argc, char **argv, char **azColName) {
            for (int i = 0; i < argc; i++) {
                printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
            }
            return 0;
        }
        
        db_query(db, "SELECT * FROM users;", callback, NULL);
        
        db_close(db);
    }
    
    return 0;
}
```

## 4. 事务处理

### SQLite 事务

```c
#include <stdio.h>
#include <sqlite3.h>

void transaction_example() {
    sqlite3 *db;
    sqlite3_open("test.db", &db);
    
    // 开始事务
    sqlite3_exec(db, "BEGIN TRANSACTION;", 0, 0, 0);
    
    // 执行多个操作
    sqlite3_exec(db, "INSERT INTO users (name, age) VALUES ('用户1', 20);",
                 0, 0, 0);
    sqlite3_exec(db, "INSERT INTO users (name, age) VALUES ('用户2', 25);",
                 0, 0, 0);
    
    // 提交事务
    sqlite3_exec(db, "COMMIT;", 0, 0, 0);
    
    // 或者回滚
    // sqlite3_exec(db, "ROLLBACK;", 0, 0, 0);
    
    sqlite3_close(db);
}
```

## 5. 错误处理

### 数据库错误处理

```c
#include <stdio.h>
#include <sqlite3.h>
#include <stdlib.h>

int db_execute_safe(sqlite3 *db, const char *sql) {
    char *err_msg = 0;
    int rc = sqlite3_exec(db, sql, 0, 0, &err_msg);
    
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL错误 [%d]: %s\n", rc, err_msg);
        fprintf(stderr, "SQL语句: %s\n", sql);
        sqlite3_free(err_msg);
        return -1;
    }
    
    return 0;
}

void error_handling_example() {
    sqlite3 *db;
    int rc = sqlite3_open("test.db", &db);
    
    if (rc != SQLITE_OK) {
        fprintf(stderr, "无法打开数据库: %s\n", sqlite3_errmsg(db));
        return;
    }
    
    // 使用安全执行函数
    if (db_execute_safe(db, "CREATE TABLE users(id INTEGER, name TEXT);") == 0) {
        printf("表创建成功\n");
    }
    
    if (db_execute_safe(db, "INSERT INTO users VALUES (1, '张三');") == 0) {
        printf("数据插入成功\n");
    }
    
    sqlite3_close(db);
}
```

## 练习

1. 实现一个完整的数据库操作库
2. 创建一个学生信息管理系统（使用SQLite）
3. 实现数据库备份和恢复功能
4. 编写一个数据库查询构建器

