# C语言预处理器和宏定义

本教程将学习C语言中的预处理器指令和宏定义，这些是编译前处理的重要工具。

## 1. 预处理器基础

### #include 指令

```c
// 包含系统头文件
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 包含用户自定义头文件
#include "myheader.h"

// 避免重复包含
#ifndef MYHEADER_H
#define MYHEADER_H
// 头文件内容
#endif
```

### #define 宏定义

```c
#include <stdio.h>

// 定义常量
#define PI 3.14159
#define MAX_SIZE 100
#define BUFFER_SIZE 1024

// 定义宏函数
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define SQUARE(x) ((x) * (x))

int main() {
    printf("PI = %.5f\n", PI);
    printf("MAX(10, 20) = %d\n", MAX(10, 20));
    printf("SQUARE(5) = %d\n", SQUARE(5));
    
    // 注意括号的重要性
    int x = 5;
    printf("SQUARE(x + 1) = %d\n", SQUARE(x + 1));  // 应该是36
    
    return 0;
}
```

## 2. 带参数的宏

### 基本用法

```c
#include <stdio.h>

// 带参数的宏
#define ADD(a, b) ((a) + (b))
#define MUL(a, b) ((a) * (b))
#define ABS(x) ((x) < 0 ? -(x) : (x))

// 多语句宏（使用do-while）
#define SWAP(a, b) do { \
    typeof(a) temp = a; \
    a = b; \
    b = temp; \
} while(0)

int main() {
    int x = 10, y = 20;
    printf("x = %d, y = %d\n", x, y);
    
    SWAP(x, y);
    printf("交换后: x = %d, y = %d\n", x, y);
    
    printf("ABS(-5) = %d\n", ABS(-5));
    printf("ABS(5) = %d\n", ABS(5));
    
    return 0;
}
```

### 注意事项

```c
#include <stdio.h>

// 错误示例：缺少括号
#define BAD_SQUARE(x) x * x

// 正确示例：带括号
#define GOOD_SQUARE(x) ((x) * (x))

int main() {
    int a = 5;
    
    // 错误宏的问题
    printf("BAD_SQUARE(a + 1) = %d\n", BAD_SQUARE(a + 1));  // 结果是11而不是36！
    
    // 正确宏
    printf("GOOD_SQUARE(a + 1) = %d\n", GOOD_SQUARE(a + 1));  // 结果是36
    
    return 0;
}
```

## 3. #ifdef, #ifndef, #endif

### 条件编译

```c
#include <stdio.h>

#define DEBUG 1

int main() {
    #ifdef DEBUG
        printf("调试模式已启用\n");
    #endif
    
    #ifndef RELEASE
        printf("这不是发布版本\n");
    #endif
    
    #if DEBUG == 1
        printf("DEBUG 级别: 1\n");
    #elif DEBUG == 2
        printf("DEBUG 级别: 2\n");
    #else
        printf("DEBUG 未启用\n");
    #endif
    
    return 0;
}
```

### 平台相关代码

```c
#include <stdio.h>

#ifdef _WIN32
    #define OS "Windows"
    #define PATH_SEPARATOR '\\'
#elif defined(__linux__)
    #define OS "Linux"
    #define PATH_SEPARATOR '/'
#elif defined(__APPLE__)
    #define OS "macOS"
    #define PATH_SEPARATOR '/'
#else
    #define OS "Unknown"
    #define PATH_SEPARATOR '/'
#endif

int main() {
    printf("当前操作系统: %s\n", OS);
    printf("路径分隔符: %c\n", PATH_SEPARATOR);
    
    return 0;
}
```

## 4. #undef 和 #pragma

### #undef 指令

```c
#include <stdio.h>

#define TEST 100

int main() {
    printf("TEST = %d\n", TEST);
    
    #undef TEST
    
    #ifdef TEST
        printf("TEST 仍定义\n");
    #else
        printf("TEST 已取消定义\n");
    #endif
    
    return 0;
}
```

### #pragma 指令

```c
#include <stdio.h>

// #pragma 用于向编译器发送特定指令
#pragma GCC diagnostic warning "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-parameter"

void function(int unused_param) {
    int unused_var = 10;
    // 由于pragma，这些未使用的变量不会产生警告
}

int main() {
    function(5);
    return 0;
}
```

## 5. 字符串化和连接

### # 和 ## 操作符

```c
#include <stdio.h>

// # 操作符：将参数转换为字符串
#define STR(x) #x
#define PRINT_VAR(var) printf("%s = %d\n", #var, var)

// ## 操作符：连接两个标识符
#define CONCAT(a, b) a##b
#define VAR_NAME(n) var_##n

int main() {
    int value = 100;
    PRINT_VAR(value);  // 输出: value = 100
    
    int var_x = 10;
    int var_y = 20;
    printf("var_x = %d\n", var_x);
    printf("var_y = %d\n", var_y);
    
    // 使用 ## 连接
    int CONCAT(num, ber) = 42;
    printf("number = %d\n", number);
    
    return 0;
}
```

### 可变参数宏

```c
#include <stdio.h>
#include <stdarg.h>

// 可变参数宏（C99标准）
#define PRINT(...) printf(__VA_ARGS__)
#define DEBUG_PRINT(fmt, ...) printf("[DEBUG] " fmt "\n", ##__VA_ARGS__)

// 使用 ##__VA_ARGS__ 可以处理空参数情况
#define LOG(fmt, ...) printf("[LOG] " fmt "\n", ##__VA_ARGS__)

int main() {
    PRINT("Hello, %s!\n", "World");
    DEBUG_PRINT("变量 x = %d, y = %d", 10, 20);
    LOG("程序启动");  // 即使没有参数也能正常工作
    
    return 0;
}
```

## 6. 头文件保护

### 防止重复包含

```c
// myheader.h
#ifndef MYHEADER_H
#define MYHEADER_H

// 头文件内容
int add(int a, int b);
int multiply(int a, int b);

#endif // MYHEADER_H
```

### #pragma once（非标准但广泛支持）

```c
// another_header.h
#pragma once  // 简化版头文件保护

// 头文件内容
void function1();
void function2();
```

## 7. 宏的高级用法

### 断言宏

```c
#include <stdio.h>
#include <stdlib.h>

#define ASSERT(condition, message) \
    do { \
        if (!(condition)) { \
            fprintf(stderr, "断言失败: %s\n", message); \
            fprintf(stderr, "文件: %s, 行: %d\n", __FILE__, __LINE__); \
            abort(); \
        } \
    } while(0)

int divide(int a, int b) {
    ASSERT(b != 0, "除数不能为0");
    return a / b;
}

int main() {
    printf("10 / 2 = %d\n", divide(10, 2));
    // printf("10 / 0 = %d\n", divide(10, 0));  // 会触发断言
    
    return 0;
}
```

### 调试宏

```c
#include <stdio.h>

#ifdef DEBUG
    #define DBG_PRINT(fmt, ...) \
        fprintf(stderr, "[%s:%d] " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)
#else
    #define DBG_PRINT(fmt, ...) ((void)0)  // 空操作
#endif

int factorial(int n) {
    DBG_PRINT("计算 factorial(%d)", n);
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

int main() {
    // 定义 DEBUG 来启用调试输出
    #define DEBUG 1
    
    int result = factorial(5);
    printf("5! = %d\n", result);
    
    return 0;
}
```

### 循环宏

```c
#include <stdio.h>

// 遍历数组的宏
#define FOREACH(item, array, size) \
    for (int i = 0; i < (size); i++) \
        for (item = (array)[i]; i < (size); break)

// 简化的循环宏
#define FOR_EACH(item, array, size) \
    for (int _i = 0; _i < (size) && (item = (array)[_i], 1); _i++)

int main() {
    int numbers[] = {10, 20, 30, 40, 50};
    int size = 5;
    
    // 使用宏遍历
    int item;
    for (int i = 0; i < size; i++) {
        item = numbers[i];
        printf("%d ", item);
    }
    printf("\n");
    
    return 0;
}
```

## 8. 预定义宏

### 标准预定义宏

```c
#include <stdio.h>

int main() {
    printf("当前文件: %s\n", __FILE__);
    printf("当前行号: %d\n", __LINE__);
    printf("当前日期: %s\n", __DATE__);
    printf("当前时间: %s\n", __TIME__);
    
    #ifdef __STDC__
        printf("符合C标准\n");
    #endif
    
    #ifdef __STDC_VERSION__
        printf("C标准版本: %ld\n", __STDC_VERSION__);
    #endif
    
    #ifdef __GNUC__
        printf("GCC版本: %d.%d\n", __GNUC__, __GNUC_MINOR__);
    #endif
    
    return 0;
}
```

## 9. 综合示例

### 示例1：泛型函数宏

```c
#include <stdio.h>
#include <string.h>

// 泛型打印宏
#define PRINT_INT(x) printf("%s = %d\n", #x, x)
#define PRINT_FLOAT(x) printf("%s = %.2f\n", #x, x)
#define PRINT_STRING(x) printf("%s = %s\n", #x, x)

// 更通用的打印宏（需要指定格式）
#define PRINT(fmt, var) printf("%s = " fmt "\n", #var, var)

int main() {
    int age = 25;
    float height = 175.5f;
    char name[] = "张三";
    
    PRINT("%d", age);
    PRINT("%.2f", height);
    PRINT("%s", name);
    
    return 0;
}
```

### 示例2：内存分配宏

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 安全的内存分配宏
#define MALLOC(type, count) \
    ((type *)malloc((count) * sizeof(type)))

#define CALLOC(type, count) \
    ((type *)calloc((count), sizeof(type)))

#define REALLOC(ptr, type, count) \
    ((type *)realloc((ptr), (count) * sizeof(type)))

#define SAFE_FREE(ptr) \
    do { \
        if (ptr != NULL) { \
            free(ptr); \
            ptr = NULL; \
        } \
    } while(0)

int main() {
    // 使用宏分配内存
    int *arr = MALLOC(int, 10);
    
    for (int i = 0; i < 10; i++) {
        arr[i] = i * 2;
    }
    
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    SAFE_FREE(arr);
    
    return 0;
}
```

### 示例3：配置文件读取宏

```c
#include <stdio.h>
#include <string.h>

#define CONFIG_MAX_LINE 256
#define CONFIG_MAX_ENTRIES 100

typedef struct {
    char key[64];
    char value[128];
} ConfigEntry;

ConfigEntry config[CONFIG_MAX_ENTRIES];
int config_count = 0;

#define PARSE_CONFIG_INT(key, var) \
    do { \
        for (int i = 0; i < config_count; i++) { \
            if (strcmp(config[i].key, key) == 0) { \
                var = atoi(config[i].value); \
                break; \
            } \
        } \
    } while(0)

#define PARSE_CONFIG_STRING(key, var, size) \
    do { \
        for (int i = 0; i < config_count; i++) { \
            if (strcmp(config[i].key, key) == 0) { \
                strncpy(var, config[i].value, size - 1); \
                var[size - 1] = '\0'; \
                break; \
            } \
        } \
    } while(0)

// 简化版的配置读取示例
void example_usage() {
    int port;
    char host[64];
    
    // 假设config已加载
    PARSE_CONFIG_INT("port", port);
    PARSE_CONFIG_STRING("host", host, sizeof(host));
    
    printf("Host: %s, Port: %d\n", host, port);
}
```

## 练习

1. 编写一个宏，实现交换两个变量（适用于任意类型）
2. 创建一个调试日志系统，使用宏实现不同级别的日志输出
3. 编写一个泛型的数组查找宏
4. 实现一个简单的单元测试框架，使用宏定义测试用例

## 注意事项

1. **括号的使用**：宏参数要用括号包围，避免运算优先级问题
2. **副作用**：宏参数可能有副作用（如自增），使用时要注意
3. **类型安全**：宏不进行类型检查，容易出错
4. **可读性**：复杂的宏会影响代码可读性，要权衡使用
5. **调试困难**：宏展开后难以调试，可以用 `gcc -E` 查看预处理结果

## 查看预处理结果

```bash
# 查看预处理后的代码
gcc -E source.c -o source.i

# 或者只预处理，不编译
cpp source.c > source.i
```

这样可以看到宏展开后的实际代码，有助于理解和调试宏定义。

