# C语言设计模式

本教程将学习如何在C语言中实现常见的设计模式，包括单例、工厂、观察者等模式。

## 1. 单例模式（Singleton）

### 线程安全的单例

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

typedef struct {
    int data;
    // 其他成员...
} Singleton;

static Singleton *instance = NULL;
static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

Singleton* get_instance() {
    if (instance == NULL) {
        pthread_mutex_lock(&mutex);
        if (instance == NULL) {  // 双重检查
            instance = (Singleton *)malloc(sizeof(Singleton));
            instance->data = 0;
            // 初始化...
        }
        pthread_mutex_unlock(&mutex);
    }
    return instance;
}

void destroy_singleton() {
    pthread_mutex_lock(&mutex);
    if (instance != NULL) {
        free(instance);
        instance = NULL;
    }
    pthread_mutex_unlock(&mutex);
}

int main() {
    Singleton *s1 = get_instance();
    Singleton *s2 = get_instance();
    
    printf("s1地址: %p\n", s1);
    printf("s2地址: %p\n", s2);
    printf("是否为同一实例: %s\n", (s1 == s2) ? "是" : "否");
    
    destroy_singleton();
    return 0;
}
```

### 使用函数指针的单例

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int value;
    void (*set_value)(int);
    int (*get_value)(void);
} Singleton;

static Singleton *instance = NULL;

static void set_value_impl(int val) {
    if (instance != NULL) {
        instance->value = val;
    }
}

static int get_value_impl(void) {
    return (instance != NULL) ? instance->value : -1;
}

Singleton* get_singleton(void) {
    if (instance == NULL) {
        instance = (Singleton *)malloc(sizeof(Singleton));
        instance->value = 0;
        instance->set_value = set_value_impl;
        instance->get_value = get_value_impl;
    }
    return instance;
}

int main() {
    Singleton *s = get_singleton();
    s->set_value(100);
    printf("值: %d\n", s->get_value());
    
    return 0;
}
```

## 2. 工厂模式（Factory）

### 简单工厂模式

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 产品接口
typedef struct {
    void (*use)(void);
    void (*destroy)(void);
} Product;

// 具体产品A
typedef struct {
    Product base;
    char name[50];
} ProductA;

void producta_use(void) {
    printf("使用产品A\n");
}

void producta_destroy(void) {
    printf("销毁产品A\n");
}

ProductA* create_producta(void) {
    ProductA *p = (ProductA *)malloc(sizeof(ProductA));
    strcpy(p->name, "ProductA");
    p->base.use = producta_use;
    p->base.destroy = producta_destroy;
    return p;
}

// 具体产品B
typedef struct {
    Product base;
    char name[50];
} ProductB;

void productb_use(void) {
    printf("使用产品B\n");
}

void productb_destroy(void) {
    printf("销毁产品B\n");
}

ProductB* create_productb(void) {
    ProductB *p = (ProductB *)malloc(sizeof(ProductB));
    strcpy(p->name, "ProductB");
    p->base.use = productb_use;
    p->base.destroy = productb_destroy;
    return p;
}

// 工厂函数
Product* create_product(const char *type) {
    if (strcmp(type, "A") == 0) {
        return (Product *)create_producta();
    } else if (strcmp(type, "B") == 0) {
        return (Product *)create_productb();
    }
    return NULL;
}

int main() {
    Product *p1 = create_product("A");
    Product *p2 = create_product("B");
    
    p1->use();
    p2->use();
    
    p1->destroy();
    p2->destroy();
    
    free(p1);
    free(p2);
    
    return 0;
}
```

### 抽象工厂模式

```c
#include <stdio.h>
#include <stdlib.h>

// 抽象产品接口
typedef struct {
    void (*render)(void);
} Button;

typedef struct {
    void (*render)(void);
} Window;

// 抽象工厂接口
typedef struct {
    Button* (*create_button)(void);
    Window* (*create_window)(void);
} UIFactory;

// Windows风格产品
typedef struct {
    Button base;
} WindowsButton;

void windows_button_render(void) {
    printf("渲染Windows风格按钮\n");
}

WindowsButton* create_windows_button(void) {
    WindowsButton *btn = (WindowsButton *)malloc(sizeof(WindowsButton));
    btn->base.render = windows_button_render;
    return btn;
}

typedef struct {
    Window base;
} WindowsWindow;

void windows_window_render(void) {
    printf("渲染Windows风格窗口\n");
}

WindowsWindow* create_windows_window(void) {
    WindowsWindow *win = (WindowsWindow *)malloc(sizeof(WindowsWindow));
    win->base.render = windows_window_render;
    return win;
}

// Linux风格产品
typedef struct {
    Button base;
} LinuxButton;

void linux_button_render(void) {
    printf("渲染Linux风格按钮\n");
}

LinuxButton* create_linux_button(void) {
    LinuxButton *btn = (LinuxButton *)malloc(sizeof(LinuxButton));
    btn->base.render = linux_button_render;
    return btn;
}

typedef struct {
    Window base;
} LinuxWindow;

void linux_window_render(void) {
    printf("渲染Linux风格窗口\n");
}

LinuxWindow* create_linux_window(void) {
    LinuxWindow *win = (LinuxWindow *)malloc(sizeof(LinuxWindow));
    win->base.render = linux_window_render;
    return win;
}

// Windows工厂
UIFactory* create_windows_factory(void) {
    UIFactory *factory = (UIFactory *)malloc(sizeof(UIFactory));
    factory->create_button = (Button* (*)(void))create_windows_button;
    factory->create_window = (Window* (*)(void))create_windows_window;
    return factory;
}

// Linux工厂
UIFactory* create_linux_factory(void) {
    UIFactory *factory = (UIFactory *)malloc(sizeof(UIFactory));
    factory->create_button = (Button* (*)(void))create_linux_button;
    factory->create_window = (Window* (*)(void))create_linux_window;
    return factory;
}

int main() {
    UIFactory *factory = create_windows_factory();
    
    Button *btn = factory->create_button();
    Window *win = factory->create_window();
    
    btn->render();
    win->render();
    
    free(btn);
    free(win);
    free(factory);
    
    return 0;
}
```

## 3. 观察者模式（Observer）

```c
#include <stdio.h>
#include <stdlib.h>

// 观察者接口
typedef struct Observer {
    void (*update)(struct Observer *self, const char *message);
    void (*destroy)(struct Observer *self);
} Observer;

// 主题（被观察者）
typedef struct {
    Observer **observers;
    int count;
    int capacity;
    char *state;
} Subject;

// 具体观察者A
typedef struct {
    Observer base;
    char name[50];
} ConcreteObserverA;

void observera_update(Observer *self, const char *message) {
    ConcreteObserverA *obs = (ConcreteObserverA *)self;
    printf("观察者A [%s] 收到消息: %s\n", obs->name, message);
}

void observera_destroy(Observer *self) {
    free(self);
}

ConcreteObserverA* create_observera(const char *name) {
    ConcreteObserverA *obs = (ConcreteObserverA *)malloc(sizeof(ConcreteObserverA));
    strcpy(obs->name, name);
    obs->base.update = observera_update;
    obs->base.destroy = observera_destroy;
    return obs;
}

// 具体观察者B
typedef struct {
    Observer base;
    char name[50];
} ConcreteObserverB;

void observerb_update(Observer *self, const char *message) {
    ConcreteObserverB *obs = (ConcreteObserverB *)self;
    printf("观察者B [%s] 收到消息: %s\n", obs->name, message);
}

void observerb_destroy(Observer *self) {
    free(self);
}

ConcreteObserverB* create_observerb(const char *name) {
    ConcreteObserverB *obs = (ConcreteObserverB *)malloc(sizeof(ConcreteObserverB));
    strcpy(obs->name, name);
    obs->base.update = observerb_update;
    obs->base.destroy = observerb_destroy;
    return obs;
}

// 主题实现
Subject* subject_create(int capacity) {
    Subject *subject = (Subject *)malloc(sizeof(Subject));
    subject->observers = (Observer **)malloc(capacity * sizeof(Observer *));
    subject->count = 0;
    subject->capacity = capacity;
    subject->state = NULL;
    return subject;
}

void subject_attach(Subject *subject, Observer *observer) {
    if (subject->count < subject->capacity) {
        subject->observers[subject->count++] = observer;
    }
}

void subject_detach(Subject *subject, Observer *observer) {
    for (int i = 0; i < subject->count; i++) {
        if (subject->observers[i] == observer) {
            for (int j = i; j < subject->count - 1; j++) {
                subject->observers[j] = subject->observers[j + 1];
            }
            subject->count--;
            break;
        }
    }
}

void subject_notify(Subject *subject, const char *message) {
    for (int i = 0; i < subject->count; i++) {
        subject->observers[i]->update(subject->observers[i], message);
    }
}

void subject_set_state(Subject *subject, const char *state) {
    subject->state = strdup(state);
    subject_notify(subject, state);
}

void subject_destroy(Subject *subject) {
    for (int i = 0; i < subject->count; i++) {
        subject->observers[i]->destroy(subject->observers[i]);
    }
    free(subject->observers);
    if (subject->state) {
        free(subject->state);
    }
    free(subject);
}

int main() {
    Subject *subject = subject_create(10);
    
    Observer *obs1 = (Observer *)create_observera("观察者1");
    Observer *obs2 = (Observer *)create_observerb("观察者2");
    Observer *obs3 = (Observer *)create_observera("观察者3");
    
    subject_attach(subject, obs1);
    subject_attach(subject, obs2);
    subject_attach(subject, obs3);
    
    subject_set_state(subject, "状态已更新");
    
    subject_detach(subject, obs2);
    subject_set_state(subject, "再次更新状态");
    
    subject_destroy(subject);
    
    return 0;
}
```

## 4. 策略模式（Strategy）

```c
#include <stdio.h>
#include <stdlib.h>

// 策略接口
typedef struct {
    int (*calculate)(int a, int b);
} Strategy;

// 加法策略
typedef struct {
    Strategy base;
} AddStrategy;

int add_calculate(int a, int b) {
    return a + b;
}

AddStrategy* create_add_strategy(void) {
    AddStrategy *s = (AddStrategy *)malloc(sizeof(AddStrategy));
    s->base.calculate = add_calculate;
    return s;
}

// 减法策略
typedef struct {
    Strategy base;
} SubtractStrategy;

int subtract_calculate(int a, int b) {
    return a - b;
}

SubtractStrategy* create_subtract_strategy(void) {
    SubtractStrategy *s = (SubtractStrategy *)malloc(sizeof(SubtractStrategy));
    s->base.calculate = subtract_calculate;
    return s;
}

// 乘法策略
typedef struct {
    Strategy base;
} MultiplyStrategy;

int multiply_calculate(int a, int b) {
    return a * b;
}

MultiplyStrategy* create_multiply_strategy(void) {
    MultiplyStrategy *s = (MultiplyStrategy *)malloc(sizeof(MultiplyStrategy));
    s->base.calculate = multiply_calculate;
    return s;
}

// 上下文
typedef struct {
    Strategy *strategy;
} Context;

Context* context_create(Strategy *strategy) {
    Context *ctx = (Context *)malloc(sizeof(Context));
    ctx->strategy = strategy;
    return ctx;
}

void context_set_strategy(Context *ctx, Strategy *strategy) {
    ctx->strategy = strategy;
}

int context_execute(Context *ctx, int a, int b) {
    return ctx->strategy->calculate(a, b);
}

int main() {
    Context *ctx = context_create((Strategy *)create_add_strategy());
    
    printf("10 + 5 = %d\n", context_execute(ctx, 10, 5));
    
    context_set_strategy(ctx, (Strategy *)create_subtract_strategy());
    printf("10 - 5 = %d\n", context_execute(ctx, 10, 5));
    
    context_set_strategy(ctx, (Strategy *)create_multiply_strategy());
    printf("10 * 5 = %d\n", context_execute(ctx, 10, 5));
    
    free(ctx);
    return 0;
}
```

## 5. 适配器模式（Adapter）

```c
#include <stdio.h>
#include <stdlib.h>

// 目标接口
typedef struct {
    void (*request)(void);
} Target;

// 需要适配的类
typedef struct {
    void (*specific_request)(void);
} Adaptee;

void adaptee_specific_request(void) {
    printf("Adaptee的特定请求\n");
}

Adaptee* create_adaptee(void) {
    Adaptee *a = (Adaptee *)malloc(sizeof(Adaptee));
    a->specific_request = adaptee_specific_request;
    return a;
}

// 适配器
typedef struct {
    Target base;
    Adaptee *adaptee;
} Adapter;

void adapter_request(void) {
    Adapter *adapter = (Adapter *)container_of(/* 需要获取Adapter指针 */);
    // 调用适配的方法
    printf("适配器转换请求\n");
    adapter->adaptee->specific_request();
}

Adapter* create_adapter(Adaptee *adaptee) {
    Adapter *adapter = (Adapter *)malloc(sizeof(Adapter));
    adapter->base.request = adapter_request;
    adapter->adaptee = adaptee;
    return adapter;
}

int main() {
    Adaptee *adaptee = create_adaptee();
    Target *target = (Target *)create_adapter(adaptee);
    
    target->request();
    
    free(target);
    free(adaptee);
    
    return 0;
}
```

## 6. 装饰器模式（Decorator）

```c
#include <stdio.h>
#include <stdlib.h>

// 组件接口
typedef struct {
    void (*operation)(void);
    void (*destroy)(void);
} Component;

// 具体组件
typedef struct {
    Component base;
} ConcreteComponent;

void concrete_operation(void) {
    printf("具体组件的操作\n");
}

ConcreteComponent* create_concrete_component(void) {
    ConcreteComponent *comp = (ConcreteComponent *)malloc(sizeof(ConcreteComponent));
    comp->base.operation = concrete_operation;
    comp->base.destroy = (void (*)(void))free;
    return comp;
}

// 装饰器基类
typedef struct {
    Component base;
    Component *component;
} Decorator;

// 具体装饰器A
typedef struct {
    Decorator base;
} ConcreteDecoratorA;

void decoratora_operation(void) {
    printf("装饰器A的额外功能\n");
    // 调用被装饰的组件
    // component->operation();
}

ConcreteDecoratorA* create_decoratora(Component *component) {
    ConcreteDecoratorA *decorator = (ConcreteDecoratorA *)malloc(sizeof(ConcreteDecoratorA));
    decorator->base.component = component;
    decorator->base.base.operation = decoratora_operation;
    return decorator;
}

int main() {
    Component *component = (Component *)create_concrete_component();
    Component *decorated = (Component *)create_decoratora(component);
    
    decorated->operation();
    
    return 0;
}
```

## 7. 命令模式（Command）

```c
#include <stdio.h>
#include <stdlib.h>

// 命令接口
typedef struct {
    void (*execute)(void);
    void (*undo)(void);
} Command;

// 接收者
typedef struct {
    int value;
} Receiver;

void receiver_action(Receiver *receiver, int delta) {
    receiver->value += delta;
    printf("接收者值: %d\n", receiver->value);
}

// 具体命令
typedef struct {
    Command base;
    Receiver *receiver;
    int delta;
} ConcreteCommand;

void command_execute(void) {
    ConcreteCommand *cmd = (ConcreteCommand *)/* 获取命令指针 */;
    receiver_action(cmd->receiver, cmd->delta);
}

void command_undo(void) {
    ConcreteCommand *cmd = (ConcreteCommand *)/* 获取命令指针 */;
    receiver_action(cmd->receiver, -cmd->delta);
}

ConcreteCommand* create_command(Receiver *receiver, int delta) {
    ConcreteCommand *cmd = (ConcreteCommand *)malloc(sizeof(ConcreteCommand));
    cmd->base.execute = command_execute;
    cmd->base.undo = command_undo;
    cmd->receiver = receiver;
    cmd->delta = delta;
    return cmd;
}

// 调用者
typedef struct {
    Command *command;
} Invoker;

void invoker_execute(Invoker *invoker) {
    if (invoker->command != NULL) {
        invoker->command->execute();
    }
}

void invoker_undo(Invoker *invoker) {
    if (invoker->command != NULL) {
        invoker->command->undo();
    }
}

int main() {
    Receiver *receiver = (Receiver *)malloc(sizeof(Receiver));
    receiver->value = 0;
    
    Command *cmd = (Command *)create_command(receiver, 10);
    
    Invoker invoker = {cmd};
    invoker_execute(&invoker);
    invoker_undo(&invoker);
    
    free(cmd);
    free(receiver);
    
    return 0;
}
```

## 练习

1. 实现一个完整的观察者模式，支持多个主题和多个观察者
2. 使用工厂模式创建一个图形库（支持不同形状）
3. 实现一个命令模式的撤销/重做系统
4. 使用策略模式实现一个排序算法库

