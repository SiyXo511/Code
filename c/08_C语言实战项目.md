# C语言实战项目

本教程包含一些综合性的实战项目，将前面学到的知识整合起来。

## 1. 学生管理系统（完整版）

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STUDENTS 100

typedef struct {
    int id;
    char name[50];
    int age;
    float score;
} Student;

Student students[MAX_STUDENTS];
int count = 0;

void add_student() {
    if (count >= MAX_STUDENTS) {
        printf("学生数量已达上限\n");
        return;
    }
    
    printf("请输入学号: ");
    scanf("%d", &students[count].id);
    printf("请输入姓名: ");
    scanf("%s", students[count].name);
    printf("请输入年龄: ");
    scanf("%d", &students[count].age);
    printf("请输入成绩: ");
    scanf("%f", &students[count].score);
    
    count++;
    printf("添加成功！\n");
}

void delete_student() {
    int id;
    printf("请输入要删除的学号: ");
    scanf("%d", &id);
    
    int found = 0;
    for (int i = 0; i < count; i++) {
        if (students[i].id == id) {
            for (int j = i; j < count - 1; j++) {
                students[j] = students[j + 1];
            }
            count--;
            found = 1;
            printf("删除成功！\n");
            break;
        }
    }
    
    if (!found) {
        printf("未找到该学号的学生\n");
    }
}

void search_student() {
    int id;
    printf("请输入要查找的学号: ");
    scanf("%d", &id);
    
    int found = 0;
    for (int i = 0; i < count; i++) {
        if (students[i].id == id) {
            printf("\n找到学生信息:\n");
            printf("学号: %d\n", students[i].id);
            printf("姓名: %s\n", students[i].name);
            printf("年龄: %d\n", students[i].age);
            printf("成绩: %.2f\n", students[i].score);
            found = 1;
            break;
        }
    }
    
    if (!found) {
        printf("未找到该学号的学生\n");
    }
}

void list_all_students() {
    if (count == 0) {
        printf("暂无学生信息\n");
        return;
    }
    
    printf("\n所有学生信息:\n");
    printf("%-5s %-15s %-5s %-5s\n", "学号", "姓名", "年龄", "成绩");
    printf("--------------------------------------------\n");
    for (int i = 0; i < count; i++) {
        printf("%-5d %-15s %-5d %-5.2f\n",
               students[i].id, students[i].name,
               students[i].age, students[i].score);
    }
}

void statistics() {
    if (count == 0) {
        printf("暂无学生信息\n");
        return;
    }
    
    float sum = 0;
    float max = students[0].score;
    float min = students[0].score;
    
    for (int i = 0; i < count; i++) {
        sum += students[i].score;
        if (students[i].score > max) {
            max = students[i].score;
        }
        if (students[i].score < min) {
            min = students[i].score;
        }
    }
    
    printf("\n统计信息:\n");
    printf("学生总数: %d\n", count);
    printf("平均成绩: %.2f\n", sum / count);
    printf("最高分: %.2f\n", max);
    printf("最低分: %.2f\n", min);
}

void save_to_file() {
    FILE *file = fopen("students.txt", "w");
    if (file == NULL) {
        printf("文件保存失败\n");
        return;
    }
    
    for (int i = 0; i < count; i++) {
        fprintf(file, "%d %s %d %.2f\n",
                students[i].id, students[i].name,
                students[i].age, students[i].score);
    }
    
    fclose(file);
    printf("数据已保存到文件\n");
}

void load_from_file() {
    FILE *file = fopen("students.txt", "r");
    if (file == NULL) {
        printf("文件不存在或无法打开\n");
        return;
    }
    
    count = 0;
    while (fscanf(file, "%d %s %d %f\n",
                  &students[count].id, students[count].name,
                  &students[count].age, &students[count].score) == 4) {
        count++;
        if (count >= MAX_STUDENTS) break;
    }
    
    fclose(file);
    printf("数据已从文件加载\n");
}

int main() {
    int choice;
    
    load_from_file();  // 程序启动时加载数据
    
    do {
        printf("\n=== 学生管理系统 ===\n");
        printf("1. 添加学生\n");
        printf("2. 删除学生\n");
        printf("3. 查找学生\n");
        printf("4. 显示所有学生\n");
        printf("5. 统计信息\n");
        printf("6. 保存到文件\n");
        printf("0. 退出\n");
        printf("请选择: ");
        scanf("%d", &choice);
        
        switch (choice) {
            case 1: add_student(); break;
            case 2: delete_student(); break;
            case 3: search_student(); break;
            case 4: list_all_students(); break;
            case 5: statistics(); break;
            case 6: save_to_file(); break;
            case 0:
                save_to_file();  // 退出前保存
                printf("再见！\n");
                break;
            default:
                printf("无效选择，请重试\n");
        }
    } while (choice != 0);
    
    return 0;
}
```

## 2. 链表实现

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node *next;
} Node;

Node* create_node(int data) {
    Node *new_node = (Node *)malloc(sizeof(Node));
    new_node->data = data;
    new_node->next = NULL;
    return new_node;
}

void insert_at_beginning(Node **head, int data) {
    Node *new_node = create_node(data);
    new_node->next = *head;
    *head = new_node;
}

void insert_at_end(Node **head, int data) {
    Node *new_node = create_node(data);
    
    if (*head == NULL) {
        *head = new_node;
        return;
    }
    
    Node *current = *head;
    while (current->next != NULL) {
        current = current->next;
    }
    current->next = new_node;
}

void delete_node(Node **head, int data) {
    if (*head == NULL) {
        return;
    }
    
    if ((*head)->data == data) {
        Node *temp = *head;
        *head = (*head)->next;
        free(temp);
        return;
    }
    
    Node *current = *head;
    while (current->next != NULL && current->next->data != data) {
        current = current->next;
    }
    
    if (current->next != NULL) {
        Node *temp = current->next;
        current->next = current->next->next;
        free(temp);
    }
}

void print_list(Node *head) {
    Node *current = head;
    while (current != NULL) {
        printf("%d -> ", current->data);
        current = current->next;
    }
    printf("NULL\n");
}

void free_list(Node **head) {
    Node *current = *head;
    while (current != NULL) {
        Node *temp = current;
        current = current->next;
        free(temp);
    }
    *head = NULL;
}

int main() {
    Node *head = NULL;
    
    insert_at_end(&head, 10);
    insert_at_end(&head, 20);
    insert_at_end(&head, 30);
    insert_at_beginning(&head, 5);
    
    printf("链表: ");
    print_list(head);
    
    delete_node(&head, 20);
    printf("删除20后: ");
    print_list(head);
    
    free_list(&head);
    
    return 0;
}
```

## 3. 栈（Stack）实现

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int top;
} Stack;

void init_stack(Stack *s) {
    s->top = -1;
}

int is_empty(Stack *s) {
    return s->top == -1;
}

int is_full(Stack *s) {
    return s->top == MAX_SIZE - 1;
}

void push(Stack *s, int value) {
    if (is_full(s)) {
        printf("栈已满，无法入栈\n");
        return;
    }
    s->data[++s->top] = value;
}

int pop(Stack *s) {
    if (is_empty(s)) {
        printf("栈为空，无法出栈\n");
        return -1;
    }
    return s->data[s->top--];
}

int peek(Stack *s) {
    if (is_empty(s)) {
        printf("栈为空\n");
        return -1;
    }
    return s->data[s->top];
}

void print_stack(Stack *s) {
    if (is_empty(s)) {
        printf("栈为空\n");
        return;
    }
    
    printf("栈内容（从底到顶）: ");
    for (int i = 0; i <= s->top; i++) {
        printf("%d ", s->data[i]);
    }
    printf("\n");
}

int main() {
    Stack s;
    init_stack(&s);
    
    push(&s, 10);
    push(&s, 20);
    push(&s, 30);
    
    print_stack(&s);
    
    printf("栈顶元素: %d\n", peek(&s));
    printf("出栈: %d\n", pop(&s));
    
    print_stack(&s);
    
    return 0;
}
```

## 4. 队列（Queue）实现

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int front;
    int rear;
} Queue;

void init_queue(Queue *q) {
    q->front = 0;
    q->rear = -1;
}

int is_empty(Queue *q) {
    return q->rear < q->front;
}

int is_full(Queue *q) {
    return q->rear == MAX_SIZE - 1;
}

void enqueue(Queue *q, int value) {
    if (is_full(q)) {
        printf("队列已满，无法入队\n");
        return;
    }
    q->data[++q->rear] = value;
}

int dequeue(Queue *q) {
    if (is_empty(q)) {
        printf("队列为空，无法出队\n");
        return -1;
    }
    return q->data[q->front++];
}

int front(Queue *q) {
    if (is_empty(q)) {
        printf("队列为空\n");
        return -1;
    }
    return q->data[q->front];
}

void print_queue(Queue *q) {
    if (is_empty(q)) {
        printf("队列为空\n");
        return;
    }
    
    printf("队列内容（从前到后）: ");
    for (int i = q->front; i <= q->rear; i++) {
        printf("%d ", q->data[i]);
    }
    printf("\n");
}

int main() {
    Queue q;
    init_queue(&q);
    
    enqueue(&q, 10);
    enqueue(&q, 20);
    enqueue(&q, 30);
    
    print_queue(&q);
    
    printf("队首元素: %d\n", front(&q));
    printf("出队: %d\n", dequeue(&q));
    
    print_queue(&q);
    
    return 0;
}
```

## 5. 排序算法实现

```c
#include <stdio.h>

void bubble_sort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

void selection_sort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int min_idx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        if (min_idx != i) {
            int temp = arr[i];
            arr[i] = arr[min_idx];
            arr[min_idx] = temp;
        }
    }
}

void insertion_sort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

void print_array(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr1[] = {64, 34, 25, 12, 22, 11, 90};
    int arr2[] = {64, 34, 25, 12, 22, 11, 90};
    int arr3[] = {64, 34, 25, 12, 22, 11, 90};
    int n = 7;
    
    printf("原数组: ");
    print_array(arr1, n);
    
    bubble_sort(arr1, n);
    printf("冒泡排序: ");
    print_array(arr1, n);
    
    selection_sort(arr2, n);
    printf("选择排序: ");
    print_array(arr2, n);
    
    insertion_sort(arr3, n);
    printf("插入排序: ");
    print_array(arr3, n);
    
    return 0;
}
```

## 6. 计算器程序

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

double calculate(double a, double b, char op) {
    switch (op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/':
            if (b != 0) {
                return a / b;
            } else {
                printf("错误：除数不能为0\n");
                return 0;
            }
        default:
            printf("错误：无效的运算符\n");
            return 0;
    }
}

int main() {
    char expression[100];
    double num1, num2, result;
    char op;
    
    printf("请输入表达式（格式：数字 运算符 数字，例如：10 + 5）: ");
    
    if (scanf("%lf %c %lf", &num1, &op, &num2) == 3) {
        result = calculate(num1, num2, op);
        printf("结果: %.2f %c %.2f = %.2f\n", num1, op, num2, result);
    } else {
        printf("输入格式错误\n");
    }
    
    return 0;
}
```

## 练习

1. 扩展学生管理系统，添加按成绩排序功能
2. 实现双向链表（Doubly Linked List）
3. 实现循环队列（Circular Queue）
4. 实现快速排序算法
5. 实现一个简单的文本编辑器（可以打开、编辑、保存文件）

## 项目建议

完成以上项目后，可以尝试：

1. **图书管理系统**：使用链表或数组管理图书信息
2. **通讯录程序**：实现联系人的增删改查功能
3. **文件加密工具**：实现简单的文件加密解密
4. **命令行工具**：实现类似Linux命令行的工具（如ls、cat等）
5. **贪吃蛇游戏**：使用C语言和图形库实现简单游戏

这些项目可以帮助你巩固C语言知识，提高编程能力！

