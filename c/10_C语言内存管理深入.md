# C语言内存管理深入

本教程将深入学习C语言中的内存管理，包括内存对齐、内存泄漏检测、动态内存管理技巧等。

## 1. 内存布局

### 程序内存分区

```c
#include <stdio.h>
#include <stdlib.h>

int global_var = 10;           // 全局变量区（已初始化）
static int static_var = 20;    // 静态变量区
int uninit_global;             // BSS段（未初始化全局变量）

void function() {
    static int static_local = 30;  // 静态局部变量
    int local_var = 40;            // 栈区
    char *heap_ptr = malloc(100);  // 堆区
    
    printf("函数局部变量地址: %p\n", &local_var);
    printf("堆内存地址: %p\n", heap_ptr);
    printf("静态局部变量地址: %p\n", &static_local);
    
    free(heap_ptr);
}

int main() {
    printf("全局变量地址: %p\n", &global_var);
    printf("静态变量地址: %p\n", &static_var);
    printf("BSS段变量地址: %p\n", &uninit_global);
    
    function();
    
    // 代码区（函数地址）
    printf("main函数地址: %p\n", (void*)main);
    printf("function函数地址: %p\n", (void*)function);
    
    return 0;
}
```

### 栈和堆的区别

| 特性 | 栈（Stack） | 堆（Heap） |
|------|------------|-----------|
| 分配方式 | 自动分配 | 手动分配 |
| 释放方式 | 自动释放 | 手动释放 |
| 大小限制 | 较小（通常几MB） | 较大（受系统限制） |
| 访问速度 | 快 | 较慢 |
| 管理方式 | 编译器管理 | 程序员管理 |

## 2. 内存对齐

### 结构体对齐

```c
#include <stdio.h>
#include <stddef.h>

struct Example1 {
    char a;     // 1字节
    int b;      // 4字节
    char c;     // 1字节
    // 总大小：12字节（对齐后）
};

struct Example2 {
    char a;     // 1字节
    char c;     // 1字节
    int b;      // 4字节
    // 总大小：8字节（优化后）
};

// 指定对齐方式（GCC扩展）
struct Example3 {
    char a;
    int b;
    char c;
} __attribute__((packed));  // 紧密排列，不填充

int main() {
    printf("Example1 大小: %lu 字节\n", sizeof(struct Example1));
    printf("Example2 大小: %lu 字节\n", sizeof(struct Example2));
    printf("Example3 大小: %lu 字节\n", sizeof(struct Example3));
    
    // 查看成员偏移量
    printf("\nExample1 成员偏移:\n");
    printf("a偏移: %lu\n", offsetof(struct Example1, a));
    printf("b偏移: %lu\n", offsetof(struct Example1, b));
    printf("c偏移: %lu\n", offsetof(struct Example1, c));
    
    return 0;
}
```

### 对齐规则

```c
#include <stdio.h>
#include <stdalign.h>

int main() {
    // 查看基本类型的对齐要求
    printf("char对齐: %lu\n", alignof(char));
    printf("short对齐: %lu\n", alignof(short));
    printf("int对齐: %lu\n", alignof(int));
    printf("long对齐: %lu\n", alignof(long));
    printf("float对齐: %lu\n", alignof(float));
    printf("double对齐: %lu\n", alignof(double));
    printf("指针对齐: %lu\n", alignof(void*));
    
    return 0;
}
```

## 3. 动态内存管理

### malloc, calloc, realloc, free

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void demonstrate_malloc() {
    // malloc: 分配未初始化的内存
    int *arr1 = (int *)malloc(10 * sizeof(int));
    if (arr1 == NULL) {
        printf("内存分配失败\n");
        return;
    }
    
    printf("malloc分配的内存（未初始化）:\n");
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr1[i]);  // 内容不确定
    }
    printf("\n");
    
    free(arr1);
}

void demonstrate_calloc() {
    // calloc: 分配并初始化为0
    int *arr2 = (int *)calloc(10, sizeof(int));
    if (arr2 == NULL) {
        printf("内存分配失败\n");
        return;
    }
    
    printf("calloc分配的内存（初始化为0）:\n");
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr2[i]);
    }
    printf("\n");
    
    free(arr2);
}

void demonstrate_realloc() {
    int *arr = (int *)malloc(5 * sizeof(int));
    if (arr == NULL) {
        return;
    }
    
    for (int i = 0; i < 5; i++) {
        arr[i] = i;
    }
    
    printf("原始数组（5个元素）:\n");
    for (int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    // 扩展到10个元素
    int *new_arr = (int *)realloc(arr, 10 * sizeof(int));
    if (new_arr == NULL) {
        free(arr);
        return;
    }
    arr = new_arr;
    
    // 初始化新增的元素
    for (int i = 5; i < 10; i++) {
        arr[i] = i;
    }
    
    printf("扩展后数组（10个元素）:\n");
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    free(arr);
}

int main() {
    demonstrate_malloc();
    demonstrate_calloc();
    demonstrate_realloc();
    
    return 0;
}
```

### 内存分配常见错误

```c
#include <stdio.h>
#include <stdlib.h>

// 错误1: 忘记检查返回值
void error1() {
    int *ptr = malloc(100);
    // 如果分配失败，ptr为NULL，使用会出错
    // *ptr = 10;  // 危险！
}

// 错误2: 内存泄漏
void error2() {
    int *ptr = malloc(100);
    // 忘记free，导致内存泄漏
    // 函数返回后无法释放这块内存
}

// 错误3: 使用已释放的内存
void error3() {
    int *ptr = malloc(sizeof(int));
    *ptr = 10;
    free(ptr);
    // *ptr = 20;  // 危险！使用野指针
    ptr = NULL;  // 应该置为NULL
}

// 错误4: 重复释放
void error4() {
    int *ptr = malloc(sizeof(int));
    free(ptr);
    // free(ptr);  // 错误！重复释放
}

// 正确做法
void correct_example() {
    int *ptr = malloc(sizeof(int));
    if (ptr == NULL) {
        printf("内存分配失败\n");
        return;
    }
    
    *ptr = 10;
    printf("值: %d\n", *ptr);
    
    free(ptr);
    ptr = NULL;  // 防止野指针
}
```

## 4. 内存泄漏检测

### 简单的内存追踪

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static size_t allocated_memory = 0;
static int allocation_count = 0;

// 追踪的malloc
void* tracked_malloc(size_t size) {
    void *ptr = malloc(size);
    if (ptr != NULL) {
        allocated_memory += size;
        allocation_count++;
        printf("[追踪] 分配 %lu 字节，总分配: %lu 字节，分配次数: %d\n",
               size, allocated_memory, allocation_count);
    }
    return ptr;
}

// 追踪的free
void tracked_free(void *ptr, size_t size) {
    if (ptr != NULL) {
        free(ptr);
        allocated_memory -= size;
        allocation_count--;
        printf("[追踪] 释放 %lu 字节，剩余: %lu 字节，剩余分配: %d\n",
               size, allocated_memory, allocation_count);
    }
}

// 检查内存泄漏
void check_memory_leak() {
    if (allocation_count != 0) {
        printf("[警告] 可能存在内存泄漏！未释放的分配: %d，未释放内存: %lu 字节\n",
               allocation_count, allocated_memory);
    } else {
        printf("[信息] 所有内存已正确释放\n");
    }
}

int main() {
    int *arr1 = (int *)tracked_malloc(10 * sizeof(int));
    int *arr2 = (int *)tracked_malloc(20 * sizeof(int));
    
    tracked_free(arr1, 10 * sizeof(int));
    // 故意不释放arr2，模拟内存泄漏
    
    check_memory_leak();
    
    return 0;
}
```

### 使用Valgrind检测内存泄漏

```c
// leak_example.c
#include <stdlib.h>

void memory_leak_example() {
    // 内存泄漏示例
    int *ptr = malloc(sizeof(int));
    *ptr = 10;
    // 忘记free(ptr)
}

int main() {
    memory_leak_example();
    return 0;
}

// 编译: gcc -g leak_example.c -o leak_example
// 运行: valgrind --leak-check=full ./leak_example
```

## 5. 智能指针模拟

### 引用计数

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    void *data;
    size_t size;
    int ref_count;  // 引用计数
} SmartPtr;

SmartPtr* smart_malloc(size_t size) {
    SmartPtr *ptr = (SmartPtr *)malloc(sizeof(SmartPtr));
    if (ptr == NULL) {
        return NULL;
    }
    
    ptr->data = malloc(size);
    if (ptr->data == NULL) {
        free(ptr);
        return NULL;
    }
    
    ptr->size = size;
    ptr->ref_count = 1;
    return ptr;
}

SmartPtr* smart_copy(SmartPtr *ptr) {
    if (ptr != NULL) {
        ptr->ref_count++;
    }
    return ptr;
}

void smart_free(SmartPtr *ptr) {
    if (ptr != NULL) {
        ptr->ref_count--;
        if (ptr->ref_count == 0) {
            free(ptr->data);
            free(ptr);
            printf("内存已释放\n");
        } else {
            printf("引用计数: %d，未释放\n", ptr->ref_count);
        }
    }
}

int main() {
    SmartPtr *ptr1 = smart_malloc(sizeof(int));
    *((int *)ptr1->data) = 10;
    
    SmartPtr *ptr2 = smart_copy(ptr1);  // 引用计数变为2
    
    printf("值: %d\n", *((int *)ptr1->data));
    
    smart_free(ptr1);  // 引用计数变为1，不释放
    smart_free(ptr2);  // 引用计数变为0，释放内存
    
    return 0;
}
```

## 6. 内存池

### 简单的内存池实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define POOL_SIZE 1024
#define BLOCK_SIZE 64
#define NUM_BLOCKS (POOL_SIZE / BLOCK_SIZE)

typedef struct {
    char pool[POOL_SIZE];
    char bitmap[NUM_BLOCKS];  // 0表示空闲，1表示已使用
    int free_count;
} MemoryPool;

MemoryPool* pool_create() {
    MemoryPool *pool = (MemoryPool *)malloc(sizeof(MemoryPool));
    if (pool == NULL) {
        return NULL;
    }
    
    memset(pool->bitmap, 0, NUM_BLOCKS);
    pool->free_count = NUM_BLOCKS;
    return pool;
}

void* pool_alloc(MemoryPool *pool, size_t size) {
    if (pool == NULL || size > BLOCK_SIZE) {
        return NULL;
    }
    
    if (pool->free_count == 0) {
        return NULL;  // 池已满
    }
    
    // 查找空闲块
    for (int i = 0; i < NUM_BLOCKS; i++) {
        if (pool->bitmap[i] == 0) {
            pool->bitmap[i] = 1;
            pool->free_count--;
            return pool->pool + (i * BLOCK_SIZE);
        }
    }
    
    return NULL;
}

void pool_free(MemoryPool *pool, void *ptr) {
    if (pool == NULL || ptr == NULL) {
        return;
    }
    
    // 计算块索引
    char *pool_start = pool->pool;
    char *block = (char *)ptr;
    
    if (block < pool_start || block >= pool_start + POOL_SIZE) {
        return;  // 不在池范围内
    }
    
    int index = (block - pool_start) / BLOCK_SIZE;
    if (index >= 0 && index < NUM_BLOCKS && pool->bitmap[index] == 1) {
        pool->bitmap[index] = 0;
        pool->free_count++;
    }
}

void pool_destroy(MemoryPool *pool) {
    if (pool != NULL) {
        free(pool);
    }
}

int main() {
    MemoryPool *pool = pool_create();
    
    void *ptr1 = pool_alloc(pool, 32);
    void *ptr2 = pool_alloc(pool, 32);
    
    if (ptr1 != NULL && ptr2 != NULL) {
        strcpy((char *)ptr1, "Hello");
        strcpy((char *)ptr2, "World");
        
        printf("ptr1: %s\n", (char *)ptr1);
        printf("ptr2: %s\n", (char *)ptr2);
        
        pool_free(pool, ptr1);
        pool_free(pool, ptr2);
    }
    
    pool_destroy(pool);
    
    return 0;
}
```

## 7. 内存对齐的动态分配

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

// 对齐的内存分配
void* aligned_malloc(size_t size, size_t alignment) {
    // 分配额外的空间用于存储原始指针
    size_t offset = alignment - 1 + sizeof(void*);
    void *original = malloc(size + offset);
    
    if (original == NULL) {
        return NULL;
    }
    
    // 计算对齐后的地址
    void *aligned = (void*)(((uintptr_t)original + sizeof(void*) + alignment - 1) 
                            & ~(alignment - 1));
    
    // 在aligned之前存储original指针
    ((void**)aligned)[-1] = original;
    
    return aligned;
}

// 对齐的内存释放
void aligned_free(void *ptr) {
    if (ptr != NULL) {
        // 获取原始指针
        void *original = ((void**)ptr)[-1];
        free(original);
    }
}

int main() {
    // 分配16字节对齐的内存
    int *arr = (int *)aligned_malloc(100 * sizeof(int), 16);
    
    if (arr != NULL) {
        printf("分配的内存地址: %p\n", arr);
        printf("地址对齐到16字节: %s\n", 
               ((uintptr_t)arr % 16 == 0) ? "是" : "否");
        
        aligned_free(arr);
    }
    
    return 0;
}
```

## 练习

1. 实现一个内存分配器，追踪所有分配的内存块
2. 实现一个内存对齐的二维数组分配函数
3. 使用内存池实现一个字符串池
4. 实现一个内存碎片整理功能

## 工具推荐

- **Valgrind**: Linux下的内存检查工具
- **AddressSanitizer (ASan)**: GCC/Clang的地址检查工具
- **Dr. Memory**: Windows/Linux的内存检查工具
- **Purify**: 商业内存检查工具

## 编译时启用内存检查

```bash
# 使用AddressSanitizer
gcc -fsanitize=address -g program.c -o program

# 使用Valgrind
valgrind --leak-check=full --show-leak-kinds=all ./program
```

