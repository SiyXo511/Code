# C语言并发编程高级

本教程将学习C语言中的高级并发编程，包括互斥量、条件变量、信号量、读写锁等内容。

## 1. 互斥量（Mutex）

### 基本使用

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

int counter = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void* increment(void *arg) {
    int iterations = *(int *)arg;
    
    for (int i = 0; i < iterations; i++) {
        pthread_mutex_lock(&mutex);  // 加锁
        counter++;
        pthread_mutex_unlock(&mutex);  // 解锁
    }
    
    return NULL;
}

int main() {
    pthread_t thread1, thread2;
    int iterations = 1000000;
    
    pthread_create(&thread1, NULL, increment, &iterations);
    pthread_create(&thread2, NULL, increment, &iterations);
    
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    
    printf("最终计数: %d (期望: %d)\n", counter, 2 * iterations);
    
    pthread_mutex_destroy(&mutex);
    return 0;
}
```

### 互斥量的高级用法

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

// 互斥量属性
void mutex_attributes() {
    pthread_mutex_t mutex;
    pthread_mutexattr_t attr;
    
    // 初始化属性
    pthread_mutexattr_init(&attr);
    
    // 设置互斥量类型
    // PTHREAD_MUTEX_NORMAL: 普通互斥量
    // PTHREAD_MUTEX_RECURSIVE: 递归互斥量
    // PTHREAD_MUTEX_ERRORCHECK: 错误检查互斥量
    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
    
    // 使用属性初始化互斥量
    pthread_mutex_init(&mutex, &attr);
    
    // 使用互斥量...
    pthread_mutex_lock(&mutex);
    pthread_mutex_unlock(&mutex);
    
    // 清理
    pthread_mutex_destroy(&mutex);
    pthread_mutexattr_destroy(&attr);
}
```

## 2. 条件变量（Condition Variable）

### 生产者-消费者模式

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define BUFFER_SIZE 10

int buffer[BUFFER_SIZE];
int count = 0;
int in = 0;
int out = 0;

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t not_full = PTHREAD_COND_INITIALIZER;
pthread_cond_t not_empty = PTHREAD_COND_INITIALIZER;

void* producer(void *arg) {
    for (int i = 0; i < 20; i++) {
        pthread_mutex_lock(&mutex);
        
        // 等待缓冲区不满
        while (count == BUFFER_SIZE) {
            pthread_cond_wait(&not_full, &mutex);
        }
        
        // 生产数据
        buffer[in] = i;
        in = (in + 1) % BUFFER_SIZE;
        count++;
        
        printf("生产者: 生产 %d\n", i);
        
        // 通知消费者
        pthread_cond_signal(&not_empty);
        pthread_mutex_unlock(&mutex);
        
        usleep(100000);  // 模拟生产时间
    }
    
    return NULL;
}

void* consumer(void *arg) {
    for (int i = 0; i < 20; i++) {
        pthread_mutex_lock(&mutex);
        
        // 等待缓冲区不空
        while (count == 0) {
            pthread_cond_wait(&not_empty, &mutex);
        }
        
        // 消费数据
        int item = buffer[out];
        out = (out + 1) % BUFFER_SIZE;
        count--;
        
        printf("消费者: 消费 %d\n", item);
        
        // 通知生产者
        pthread_cond_signal(&not_full);
        pthread_mutex_unlock(&mutex);
        
        usleep(150000);  // 模拟消费时间
    }
    
    return NULL;
}

int main() {
    pthread_t producer_thread, consumer_thread;
    
    pthread_create(&producer_thread, NULL, producer, NULL);
    pthread_create(&consumer_thread, NULL, consumer, NULL);
    
    pthread_join(producer_thread, NULL);
    pthread_join(consumer_thread, NULL);
    
    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&not_full);
    pthread_cond_destroy(&not_empty);
    
    return 0;
}
```

## 3. 信号量（Semaphore）

### 使用信号量控制并发

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define MAX_CONCURRENT 3
#define TOTAL_TASKS 10

sem_t semaphore;

void* worker(void *arg) {
    int task_id = *(int *)arg;
    
    sem_wait(&semaphore);  // 等待信号量
    
    printf("任务 %d 开始执行\n", task_id);
    sleep(2);  // 模拟工作
    printf("任务 %d 完成\n", task_id);
    
    sem_post(&semaphore);  // 释放信号量
    
    return NULL;
}

int main() {
    pthread_t threads[TOTAL_TASKS];
    int task_ids[TOTAL_TASKS];
    
    // 初始化信号量，允许最多3个并发任务
    sem_init(&semaphore, 0, MAX_CONCURRENT);
    
    // 创建线程
    for (int i = 0; i < TOTAL_TASKS; i++) {
        task_ids[i] = i;
        pthread_create(&threads[i], NULL, worker, &task_ids[i]);
    }
    
    // 等待所有线程完成
    for (int i = 0; i < TOTAL_TASKS; i++) {
        pthread_join(threads[i], NULL);
    }
    
    sem_destroy(&semaphore);
    
    return 0;
}
```

### 使用信号量实现生产者-消费者

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define BUFFER_SIZE 5

int buffer[BUFFER_SIZE];
int in = 0, out = 0;

sem_t empty;  // 空槽位数量
sem_t full;   // 满槽位数量
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void* producer_sem(void *arg) {
    for (int i = 0; i < 10; i++) {
        sem_wait(&empty);  // 等待空槽位
        pthread_mutex_lock(&mutex);
        
        buffer[in] = i;
        in = (in + 1) % BUFFER_SIZE;
        printf("生产者: 生产 %d\n", i);
        
        pthread_mutex_unlock(&mutex);
        sem_post(&full);   // 增加满槽位
        
        usleep(100000);
    }
    return NULL;
}

void* consumer_sem(void *arg) {
    for (int i = 0; i < 10; i++) {
        sem_wait(&full);   // 等待满槽位
        pthread_mutex_lock(&mutex);
        
        int item = buffer[out];
        out = (out + 1) % BUFFER_SIZE;
        printf("消费者: 消费 %d\n", item);
        
        pthread_mutex_unlock(&mutex);
        sem_post(&empty);  // 增加空槽位
        
        usleep(150000);
    }
    return NULL;
}

int main() {
    sem_init(&empty, 0, BUFFER_SIZE);
    sem_init(&full, 0, 0);
    
    pthread_t producer_thread, consumer_thread;
    
    pthread_create(&producer_thread, NULL, producer_sem, NULL);
    pthread_create(&consumer_thread, NULL, consumer_sem, NULL);
    
    pthread_join(producer_thread, NULL);
    pthread_join(consumer_thread, NULL);
    
    sem_destroy(&empty);
    sem_destroy(&full);
    pthread_mutex_destroy(&mutex);
    
    return 0;
}
```

## 4. 读写锁（Read-Write Lock）

### 读写锁实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

int shared_data = 0;
int reader_count = 0;
pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;

void* reader(void *arg) {
    int id = *(int *)arg;
    
    for (int i = 0; i < 5; i++) {
        pthread_rwlock_rdlock(&rwlock);  // 读锁
        
        printf("读者 %d: 读取数据 = %d\n", id, shared_data);
        usleep(100000);
        
        pthread_rwlock_unlock(&rwlock);
        usleep(200000);
    }
    
    return NULL;
}

void* writer(void *arg) {
    int id = *(int *)arg;
    
    for (int i = 0; i < 3; i++) {
        pthread_rwlock_wrlock(&rwlock);  // 写锁
        
        shared_data++;
        printf("写者 %d: 写入数据 = %d\n", id, shared_data);
        usleep(200000);
        
        pthread_rwlock_unlock(&rwlock);
        usleep(300000);
    }
    
    return NULL;
}

int main() {
    pthread_t readers[3], writers[2];
    int reader_ids[3] = {1, 2, 3};
    int writer_ids[2] = {1, 2};
    
    // 创建读者线程
    for (int i = 0; i < 3; i++) {
        pthread_create(&readers[i], NULL, reader, &reader_ids[i]);
    }
    
    // 创建写者线程
    for (int i = 0; i < 2; i++) {
        pthread_create(&writers[i], NULL, writer, &writer_ids[i]);
    }
    
    // 等待所有线程
    for (int i = 0; i < 3; i++) {
        pthread_join(readers[i], NULL);
    }
    for (int i = 0; i < 2; i++) {
        pthread_join(writers[i], NULL);
    }
    
    pthread_rwlock_destroy(&rwlock);
    
    return 0;
}
```

## 5. 屏障（Barrier）

### 使用屏障同步线程

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define NUM_THREADS 4

pthread_barrier_t barrier;

void* worker_barrier(void *arg) {
    int id = *(int *)arg;
    
    printf("线程 %d: 开始工作\n", id);
    sleep(1 + id);  // 模拟工作时间不同
    
    printf("线程 %d: 工作完成，等待其他线程\n", id);
    pthread_barrier_wait(&barrier);  // 等待所有线程到达
    
    printf("线程 %d: 所有线程已同步，继续执行\n", id);
    
    return NULL;
}

int main() {
    pthread_t threads[NUM_THREADS];
    int thread_ids[NUM_THREADS];
    
    // 初始化屏障，等待4个线程
    pthread_barrier_init(&barrier, NULL, NUM_THREADS);
    
    // 创建线程
    for (int i = 0; i < NUM_THREADS; i++) {
        thread_ids[i] = i;
        pthread_create(&threads[i], NULL, worker_barrier, &thread_ids[i]);
    }
    
    // 等待所有线程完成
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }
    
    pthread_barrier_destroy(&barrier);
    
    return 0;
}
```

## 6. 自旋锁（Spin Lock）

### 自旋锁实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

int counter = 0;
pthread_spinlock_t spinlock;

void* increment_spin(void *arg) {
    int iterations = *(int *)arg;
    
    for (int i = 0; i < iterations; i++) {
        pthread_spin_lock(&spinlock);
        counter++;
        pthread_spin_unlock(&spinlock);
    }
    
    return NULL;
}

int main() {
    pthread_spin_init(&spinlock, PTHREAD_PROCESS_PRIVATE);
    
    pthread_t thread1, thread2;
    int iterations = 1000000;
    
    pthread_create(&thread1, NULL, increment_spin, &iterations);
    pthread_create(&thread2, NULL, increment_spin, &iterations);
    
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    
    printf("最终计数: %d\n", counter);
    
    pthread_spin_destroy(&spinlock);
    return 0;
}
```

## 7. 线程安全的数据结构

### 线程安全的队列

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

typedef struct Node {
    int data;
    struct Node *next;
} Node;

typedef struct {
    Node *head;
    Node *tail;
    pthread_mutex_t mutex;
    int size;
} ThreadSafeQueue;

ThreadSafeQueue* queue_create() {
    ThreadSafeQueue *queue = (ThreadSafeQueue *)malloc(sizeof(ThreadSafeQueue));
    queue->head = NULL;
    queue->tail = NULL;
    queue->size = 0;
    pthread_mutex_init(&queue->mutex, NULL);
    return queue;
}

void queue_enqueue(ThreadSafeQueue *queue, int data) {
    Node *new_node = (Node *)malloc(sizeof(Node));
    new_node->data = data;
    new_node->next = NULL;
    
    pthread_mutex_lock(&queue->mutex);
    
    if (queue->tail == NULL) {
        queue->head = new_node;
        queue->tail = new_node;
    } else {
        queue->tail->next = new_node;
        queue->tail = new_node;
    }
    queue->size++;
    
    pthread_mutex_unlock(&queue->mutex);
}

int queue_dequeue(ThreadSafeQueue *queue, int *data) {
    pthread_mutex_lock(&queue->mutex);
    
    if (queue->head == NULL) {
        pthread_mutex_unlock(&queue->mutex);
        return 0;
    }
    
    Node *temp = queue->head;
    *data = temp->data;
    queue->head = queue->head->next;
    
    if (queue->head == NULL) {
        queue->tail = NULL;
    }
    queue->size--;
    
    pthread_mutex_unlock(&queue->mutex);
    free(temp);
    
    return 1;
}

int main() {
    ThreadSafeQueue *queue = queue_create();
    
    queue_enqueue(queue, 10);
    queue_enqueue(queue, 20);
    queue_enqueue(queue, 30);
    
    int value;
    while (queue_dequeue(queue, &value)) {
        printf("出队: %d\n", value);
    }
    
    return 0;
}
```

## 8. 死锁预防

### 死锁示例和预防

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t mutex2 = PTHREAD_MUTEX_INITIALIZER;

// 死锁示例（错误代码）
void* deadlock_thread1(void *arg) {
    pthread_mutex_lock(&mutex1);
    sleep(1);
    pthread_mutex_lock(&mutex2);  // 可能死锁
    // ...
    pthread_mutex_unlock(&mutex2);
    pthread_mutex_unlock(&mutex1);
    return NULL;
}

void* deadlock_thread2(void *arg) {
    pthread_mutex_lock(&mutex2);
    sleep(1);
    pthread_mutex_lock(&mutex1);  // 可能死锁
    // ...
    pthread_mutex_unlock(&mutex1);
    pthread_mutex_unlock(&mutex2);
    return NULL;
}

// 死锁预防：统一锁定顺序
void* safe_thread1(void *arg) {
    pthread_mutex_lock(&mutex1);
    pthread_mutex_lock(&mutex2);  // 总是先锁定mutex1
    // ...
    pthread_mutex_unlock(&mutex2);
    pthread_mutex_unlock(&mutex1);
    return NULL;
}

void* safe_thread2(void *arg) {
    pthread_mutex_lock(&mutex1);  // 总是先锁定mutex1
    pthread_mutex_lock(&mutex2);
    // ...
    pthread_mutex_unlock(&mutex2);
    pthread_mutex_unlock(&mutex1);
    return NULL;
}

// 使用超时避免死锁
int mutex_lock_timeout(pthread_mutex_t *mutex, int timeout_sec) {
    struct timespec timeout;
    clock_gettime(CLOCK_REALTIME, &timeout);
    timeout.tv_sec += timeout_sec;
    
    return pthread_mutex_timedlock(mutex, &timeout);
}
```

## 练习

1. 实现一个线程安全的哈希表
2. 使用条件变量实现一个任务队列
3. 实现读者-写者问题的多个变种
4. 创建一个线程池（Thread Pool）

