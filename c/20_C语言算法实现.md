# C语言算法实现

本教程将学习C语言中常用算法的实现，包括排序算法、查找算法、图算法等。

## 1. 排序算法

### 快速排序

```c
#include <stdio.h>
#include <stdlib.h>

void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return i + 1;
}

void quick_sort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quick_sort(arr, low, pi - 1);
        quick_sort(arr, pi + 1, high);
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    printf("排序前: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    quick_sort(arr, 0, n - 1);
    
    printf("排序后: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    return 0;
}
```

### 归并排序

```c
#include <stdio.h>
#include <stdlib.h>

void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    
    int *left_arr = (int *)malloc(n1 * sizeof(int));
    int *right_arr = (int *)malloc(n2 * sizeof(int));
    
    for (int i = 0; i < n1; i++) {
        left_arr[i] = arr[left + i];
    }
    for (int j = 0; j < n2; j++) {
        right_arr[j] = arr[mid + 1 + j];
    }
    
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (left_arr[i] <= right_arr[j]) {
            arr[k++] = left_arr[i++];
        } else {
            arr[k++] = right_arr[j++];
        }
    }
    
    while (i < n1) {
        arr[k++] = left_arr[i++];
    }
    while (j < n2) {
        arr[k++] = right_arr[j++];
    }
    
    free(left_arr);
    free(right_arr);
}

void merge_sort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        merge_sort(arr, left, mid);
        merge_sort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    merge_sort(arr, 0, n - 1);
    
    printf("归并排序结果: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    return 0;
}
```

### 堆排序

```c
#include <stdio.h>

void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    
    if (largest != i) {
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;
        heapify(arr, n, largest);
    }
}

void heap_sort(int arr[], int n) {
    // 构建最大堆
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    // 逐个取出堆顶元素
    for (int i = n - 1; i > 0; i--) {
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        heapify(arr, i, 0);
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    heap_sort(arr, n);
    
    printf("堆排序结果: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    return 0;
}
```

## 2. 查找算法

### 二分查找

```c
#include <stdio.h>

// 二分查找（数组必须有序）
int binary_search(int arr[], int left, int right, int target) {
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;  // 未找到
}

int main() {
    int arr[] = {11, 12, 22, 25, 34, 64, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    int target = 25;
    
    int index = binary_search(arr, 0, n - 1, target);
    if (index != -1) {
        printf("找到 %d，位置: %d\n", target, index);
    } else {
        printf("未找到 %d\n", target);
    }
    
    return 0;
}
```

## 3. 图算法

### 图的表示（邻接表）

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct GraphNode {
    int vertex;
    struct GraphNode *next;
} GraphNode;

typedef struct {
    int num_vertices;
    GraphNode **adj_list;
} Graph;

Graph* graph_create(int num_vertices) {
    Graph *graph = (Graph *)malloc(sizeof(Graph));
    graph->num_vertices = num_vertices;
    graph->adj_list = (GraphNode **)calloc(num_vertices, sizeof(GraphNode *));
    return graph;
}

void graph_add_edge(Graph *graph, int src, int dest) {
    // 添加边 src -> dest
    GraphNode *new_node = (GraphNode *)malloc(sizeof(GraphNode));
    new_node->vertex = dest;
    new_node->next = graph->adj_list[src];
    graph->adj_list[src] = new_node;
    
    // 无向图：也添加边 dest -> src
    new_node = (GraphNode *)malloc(sizeof(GraphNode));
    new_node->vertex = src;
    new_node->next = graph->adj_list[dest];
    graph->adj_list[dest] = new_node;
}

void graph_print(Graph *graph) {
    for (int i = 0; i < graph->num_vertices; i++) {
        printf("顶点 %d: ", i);
        GraphNode *current = graph->adj_list[i];
        while (current != NULL) {
            printf("%d -> ", current->vertex);
            current = current->next;
        }
        printf("NULL\n");
    }
}

// 深度优先搜索（DFS）
void dfs_recursive(Graph *graph, int vertex, int visited[]) {
    visited[vertex] = 1;
    printf("%d ", vertex);
    
    GraphNode *current = graph->adj_list[vertex];
    while (current != NULL) {
        if (!visited[current->vertex]) {
            dfs_recursive(graph, current->vertex, visited);
        }
        current = current->next;
    }
}

// 广度优先搜索（BFS）
void bfs(Graph *graph, int start_vertex) {
    int *visited = (int *)calloc(graph->num_vertices, sizeof(int));
    int *queue = (int *)malloc(graph->num_vertices * sizeof(int));
    int front = 0, rear = 0;
    
    visited[start_vertex] = 1;
    queue[rear++] = start_vertex;
    
    printf("BFS遍历: ");
    while (front < rear) {
        int vertex = queue[front++];
        printf("%d ", vertex);
        
        GraphNode *current = graph->adj_list[vertex];
        while (current != NULL) {
            if (!visited[current->vertex]) {
                visited[current->vertex] = 1;
                queue[rear++] = current->vertex;
            }
            current = current->next;
        }
    }
    printf("\n");
    
    free(visited);
    free(queue);
}

int main() {
    Graph *graph = graph_create(5);
    
    graph_add_edge(graph, 0, 1);
    graph_add_edge(graph, 0, 2);
    graph_add_edge(graph, 1, 3);
    graph_add_edge(graph, 2, 4);
    
    graph_print(graph);
    
    int *visited = (int *)calloc(graph->num_vertices, sizeof(int));
    printf("DFS遍历: ");
    dfs_recursive(graph, 0, visited);
    printf("\n");
    
    bfs(graph, 0);
    
    free(visited);
    return 0;
}
```

## 4. 字符串算法

### KMP字符串匹配

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 构建失败函数（部分匹配表）
void compute_lps(char *pattern, int m, int *lps) {
    int len = 0;
    lps[0] = 0;
    int i = 1;
    
    while (i < m) {
        if (pattern[i] == pattern[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
}

// KMP字符串匹配算法
int kmp_search(char *text, char *pattern) {
    int n = strlen(text);
    int m = strlen(pattern);
    
    int *lps = (int *)malloc(m * sizeof(int));
    compute_lps(pattern, m, lps);
    
    int i = 0;  // text的索引
    int j = 0;  // pattern的索引
    
    while (i < n) {
        if (pattern[j] == text[i]) {
            i++;
            j++;
        }
        
        if (j == m) {
            free(lps);
            return i - j;  // 找到匹配
        } else if (i < n && pattern[j] != text[i]) {
            if (j != 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
    
    free(lps);
    return -1;  // 未找到
}

int main() {
    char text[] = "ABABDABACDABABCABC";
    char pattern[] = "ABABCABC";
    
    int pos = kmp_search(text, pattern);
    if (pos != -1) {
        printf("模式在位置 %d 找到\n", pos);
    } else {
        printf("模式未找到\n");
    }
    
    return 0;
}
```

## 5. 动态规划

### 斐波那契数列（动态规划）

```c
#include <stdio.h>
#include <stdlib.h>

// 递归版本（慢）
long long fibonacci_recursive(int n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2);
}

// 动态规划版本（快）
long long fibonacci_dp(int n) {
    if (n <= 1) {
        return n;
    }
    
    long long *dp = (long long *)malloc((n + 1) * sizeof(long long));
    dp[0] = 0;
    dp[1] = 1;
    
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    long long result = dp[n];
    free(dp);
    return result;
}

// 优化的动态规划（只保存前两个值）
long long fibonacci_optimized(int n) {
    if (n <= 1) {
        return n;
    }
    
    long long prev2 = 0;
    long long prev1 = 1;
    
    for (int i = 2; i <= n; i++) {
        long long current = prev1 + prev2;
        prev2 = prev1;
        prev1 = current;
    }
    
    return prev1;
}

int main() {
    int n = 40;
    
    printf("计算斐波那契数列第%d项:\n", n);
    printf("动态规划版本: %lld\n", fibonacci_dp(n));
    printf("优化版本: %lld\n", fibonacci_optimized(n));
    
    return 0;
}
```

### 最长公共子序列（LCS）

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int max(int a, int b) {
    return (a > b) ? a : b;
}

// 最长公共子序列
int lcs(char *str1, char *str2, int m, int n) {
    int **dp = (int **)malloc((m + 1) * sizeof(int *));
    for (int i = 0; i <= m; i++) {
        dp[i] = (int *)malloc((n + 1) * sizeof(int));
    }
    
    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
            if (i == 0 || j == 0) {
                dp[i][j] = 0;
            } else if (str1[i - 1] == str2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    int result = dp[m][n];
    
    for (int i = 0; i <= m; i++) {
        free(dp[i]);
    }
    free(dp);
    
    return result;
}

int main() {
    char str1[] = "ABCDGH";
    char str2[] = "AEDFHR";
    
    int m = strlen(str1);
    int n = strlen(str2);
    
    int length = lcs(str1, str2, m, n);
    printf("字符串1: %s\n", str1);
    printf("字符串2: %s\n", str2);
    printf("最长公共子序列长度: %d\n", length);
    
    return 0;
}
```

## 练习

1. 实现所有常见排序算法（冒泡、选择、插入、希尔、快速、归并、堆排序）
2. 实现图的拓扑排序
3. 实现最短路径算法（Dijkstra、Floyd-Warshall）
4. 实现最小生成树算法（Prim、Kruskal）

