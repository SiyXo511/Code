# C语言位操作和底层编程

本教程将学习C语言中的位操作、位域、底层编程技巧等内容。

## 1. 位运算符

### 基本位运算符

```c
#include <stdio.h>

void print_binary(unsigned int num) {
    for (int i = 31; i >= 0; i--) {
        printf("%d", (num >> i) & 1);
        if (i % 4 == 0 && i != 0) printf(" ");
    }
    printf("\n");
}

int main() {
    unsigned int a = 12;  // 0000 1100
    unsigned int b = 10;  // 0000 1010
    
    printf("a = %u, 二进制: ", a);
    print_binary(a);
    
    printf("b = %u, 二进制: ", b);
    print_binary(b);
    
    // 按位与 &
    printf("\na & b = %u\n", a & b);
    print_binary(a & b);
    
    // 按位或 |
    printf("\na | b = %u\n", a | b);
    print_binary(a | b);
    
    // 按位异或 ^
    printf("\na ^ b = %u\n", a ^ b);
    print_binary(a ^ b);
    
    // 按位取反 ~
    printf("\n~a = %u\n", ~a);
    print_binary(~a);
    
    return 0;
}
```

### 移位运算符

```c
#include <stdio.h>

void print_binary(unsigned int num) {
    for (int i = 7; i >= 0; i--) {
        printf("%d", (num >> i) & 1);
    }
    printf("\n");
}

int main() {
    unsigned char x = 0b00011000;  // 24
    
    printf("原值 x = %u, 二进制: ", x);
    print_binary(x);
    
    // 左移 <<
    unsigned char left_shift = x << 2;  // 左移2位（相当于乘以4）
    printf("x << 2 = %u, 二进制: ", left_shift);
    print_binary(left_shift);
    
    // 右移 >>
    unsigned char right_shift = x >> 2;  // 右移2位（相当于除以4）
    printf("x >> 2 = %u, 二进制: ", right_shift);
    print_binary(right_shift);
    
    return 0;
}
```

## 2. 位操作技巧

### 设置位

```c
#include <stdio.h>

// 设置第n位为1
unsigned int set_bit(unsigned int num, int n) {
    return num | (1 << n);
}

// 设置第n位为0
unsigned int clear_bit(unsigned int num, int n) {
    return num & ~(1 << n);
}

// 切换第n位（0变1，1变0）
unsigned int toggle_bit(unsigned int num, int n) {
    return num ^ (1 << n);
}

// 检查第n位是否为1
int check_bit(unsigned int num, int n) {
    return (num >> n) & 1;
}

int main() {
    unsigned int x = 0b00001010;  // 10
    
    printf("原值: %u\n", x);
    
    x = set_bit(x, 3);
    printf("设置第3位后: %u\n", x);
    
    x = clear_bit(x, 1);
    printf("清除第1位后: %u\n", x);
    
    x = toggle_bit(x, 0);
    printf("切换第0位后: %u\n", x);
    
    printf("第2位是否为1: %d\n", check_bit(x, 2));
    
    return 0;
}
```

### 常用位操作算法

```c
#include <stdio.h>

// 计算1的个数（Brian Kernighan算法）
int count_ones(unsigned int num) {
    int count = 0;
    while (num) {
        num &= (num - 1);  // 清除最低位的1
        count++;
    }
    return count;
}

// 判断是否为2的幂
int is_power_of_two(unsigned int num) {
    return num != 0 && (num & (num - 1)) == 0;
}

// 获取最低位的1
unsigned int lowest_set_bit(unsigned int num) {
    return num & (-num);
}

// 交换两个变量（不使用临时变量）
void swap_xor(int *a, int *b) {
    *a = *a ^ *b;
    *b = *a ^ *b;
    *a = *a ^ *b;
}

// 反转二进制位
unsigned int reverse_bits(unsigned int num) {
    unsigned int result = 0;
    int bits = sizeof(num) * 8;
    
    for (int i = 0; i < bits; i++) {
        result <<= 1;
        result |= num & 1;
        num >>= 1;
    }
    
    return result;
}

int main() {
    unsigned int x = 0b10101010;
    
    printf("数字: %u\n", x);
    printf("1的个数: %d\n", count_ones(x));
    printf("是否为2的幂: %d\n", is_power_of_two(16));
    printf("最低位的1: %u\n", lowest_set_bit(x));
    
    int a = 10, b = 20;
    printf("\n交换前: a = %d, b = %d\n", a, b);
    swap_xor(&a, &b);
    printf("交换后: a = %d, b = %d\n", a, b);
    
    return 0;
}
```

## 3. 位域

### 结构体位域

```c
#include <stdio.h>

// 位域：节省内存空间
struct Date {
    unsigned int day : 5;      // 5位，可以表示0-31
    unsigned int month : 4;    // 4位，可以表示0-15
    unsigned int year : 11;    // 11位，可以表示0-2047
};

struct Status {
    unsigned int is_active : 1;     // 1位：是否激活
    unsigned int is_visible : 1;    // 1位：是否可见
    unsigned int is_enabled : 1;    // 1位：是否启用
    unsigned int : 0;               // 未命名位域：强制对齐
    unsigned int priority : 3;      // 3位：优先级
};

int main() {
    struct Date date;
    date.day = 15;
    date.month = 6;
    date.year = 2024;
    
    printf("日期: %d/%d/%d\n", date.day, date.month, date.year);
    printf("Date大小: %lu 字节\n", sizeof(struct Date));
    
    struct Status status;
    status.is_active = 1;
    status.is_visible = 1;
    status.is_enabled = 0;
    status.priority = 5;
    
    printf("\n状态:\n");
    printf("激活: %d\n", status.is_active);
    printf("可见: %d\n", status.is_visible);
    printf("启用: %d\n", status.is_enabled);
    printf("优先级: %d\n", status.priority);
    printf("Status大小: %lu 字节\n", sizeof(struct Status));
    
    return 0;
}
```

## 4. 字节序（Endianness）

### 检测字节序

```c
#include <stdio.h>

void check_endianness() {
    int num = 0x12345678;
    unsigned char *bytes = (unsigned char *)&num;
    
    printf("数字: 0x%x\n", num);
    printf("内存中的字节:\n");
    
    for (int i = 0; i < sizeof(int); i++) {
        printf("字节[%d]: 0x%02x\n", i, bytes[i]);
    }
    
    if (bytes[0] == 0x78) {
        printf("\n系统是小端序（Little Endian）\n");
    } else if (bytes[0] == 0x12) {
        printf("\n系统是大端序（Big Endian）\n");
    }
}

// 网络字节序转换（大端序）
uint16_t htons(uint16_t hostshort) {
    unsigned char *bytes = (unsigned char *)&hostshort;
    return (bytes[0] << 8) | bytes[1];
}

uint32_t htonl(uint32_t hostlong) {
    unsigned char *bytes = (unsigned char *)&hostlong;
    return (bytes[0] << 24) | (bytes[1] << 16) | 
           (bytes[2] << 8) | bytes[3];
}

int main() {
    check_endianness();
    
    uint16_t port = 8080;
    printf("\n本地端口: %u\n", port);
    printf("网络字节序: %u\n", htons(port));
    
    return 0;
}
```

## 5. 位掩码

### 使用位掩码管理标志

```c
#include <stdio.h>

// 定义标志位
#define FLAG_READ     (1 << 0)  // 0001
#define FLAG_WRITE    (1 << 1)  // 0010
#define FLAG_EXECUTE  (1 << 2)  // 0100
#define FLAG_HIDDEN   (1 << 3)  // 1000

void print_permissions(unsigned int flags) {
    printf("权限: ");
    if (flags & FLAG_READ) printf("r");
    else printf("-");
    
    if (flags & FLAG_WRITE) printf("w");
    else printf("-");
    
    if (flags & FLAG_EXECUTE) printf("x");
    else printf("-");
    
    if (flags & FLAG_HIDDEN) printf(" (隐藏)");
    printf("\n");
}

int main() {
    unsigned int file_flags = FLAG_READ | FLAG_WRITE;  // 读写权限
    
    print_permissions(file_flags);
    
    // 添加执行权限
    file_flags |= FLAG_EXECUTE;
    print_permissions(file_flags);
    
    // 移除写权限
    file_flags &= ~FLAG_WRITE;
    print_permissions(file_flags);
    
    // 切换隐藏标志
    file_flags ^= FLAG_HIDDEN;
    print_permissions(file_flags);
    
    return 0;
}
```

## 6. 位集合（Bit Set）

### 实现位集合

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#define BITS_PER_WORD 32
#define WORD_OFFSET(b) ((b) / BITS_PER_WORD)
#define BIT_OFFSET(b) ((b) % BITS_PER_WORD)

typedef struct {
    uint32_t *bits;
    size_t size;  // 位数量
} BitSet;

BitSet* bitset_create(size_t size) {
    BitSet *bs = (BitSet *)malloc(sizeof(BitSet));
    size_t word_count = (size + BITS_PER_WORD - 1) / BITS_PER_WORD;
    bs->bits = (uint32_t *)calloc(word_count, sizeof(uint32_t));
    bs->size = size;
    return bs;
}

void bitset_destroy(BitSet *bs) {
    if (bs != NULL) {
        free(bs->bits);
        free(bs);
    }
}

void bitset_set(BitSet *bs, size_t bit) {
    if (bit < bs->size) {
        bs->bits[WORD_OFFSET(bit)] |= (1 << BIT_OFFSET(bit));
    }
}

void bitset_clear(BitSet *bs, size_t bit) {
    if (bit < bs->size) {
        bs->bits[WORD_OFFSET(bit)] &= ~(1 << BIT_OFFSET(bit));
    }
}

int bitset_test(BitSet *bs, size_t bit) {
    if (bit < bs->size) {
        return (bs->bits[WORD_OFFSET(bit)] >> BIT_OFFSET(bit)) & 1;
    }
    return 0;
}

void bitset_print(BitSet *bs) {
    for (size_t i = 0; i < bs->size; i++) {
        printf("%d", bitset_test(bs, i));
        if ((i + 1) % 8 == 0) printf(" ");
    }
    printf("\n");
}

int main() {
    BitSet *bs = bitset_create(32);
    
    bitset_set(bs, 0);
    bitset_set(bs, 2);
    bitset_set(bs, 5);
    bitset_set(bs, 10);
    
    printf("位集合: ");
    bitset_print(bs);
    
    printf("第5位是否为1: %d\n", bitset_test(bs, 5));
    
    bitset_clear(bs, 5);
    printf("清除第5位后: ");
    bitset_print(bs);
    
    bitset_destroy(bs);
    
    return 0;
}
```

## 7. 内存操作

### 内存复制和比较

```c
#include <stdio.h>
#include <string.h>
#include <stdint.h>

// 使用memcpy进行内存复制
void example_memcpy() {
    int src[] = {1, 2, 3, 4, 5};
    int dest[5];
    
    memcpy(dest, src, sizeof(src));
    
    printf("复制后dest数组: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", dest[i]);
    }
    printf("\n");
}

// 使用memset初始化内存
void example_memset() {
    int arr[10];
    memset(arr, 0, sizeof(arr));  // 初始化为0
    
    printf("memset初始化后: ");
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// 使用memcmp比较内存
void example_memcmp() {
    int arr1[] = {1, 2, 3, 4, 5};
    int arr2[] = {1, 2, 3, 4, 5};
    int arr3[] = {1, 2, 3, 4, 6};
    
    if (memcmp(arr1, arr2, sizeof(arr1)) == 0) {
        printf("arr1 和 arr2 相等\n");
    }
    
    if (memcmp(arr1, arr3, sizeof(arr1)) != 0) {
        printf("arr1 和 arr3 不相等\n");
    }
}

int main() {
    example_memcpy();
    example_memset();
    example_memcmp();
    
    return 0;
}
```

## 8. 综合示例

### 示例1：位图数据结构

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

// 简化的位图实现
typedef struct {
    uint32_t *data;
    size_t width;
    size_t height;
} Bitmap;

Bitmap* bitmap_create(size_t width, size_t height) {
    Bitmap *bm = (Bitmap *)malloc(sizeof(Bitmap));
    size_t words = (width * height + 31) / 32;
    bm->data = (uint32_t *)calloc(words, sizeof(uint32_t));
    bm->width = width;
    bm->height = height;
    return bm;
}

void bitmap_set_pixel(Bitmap *bm, size_t x, size_t y) {
    if (x < bm->width && y < bm->height) {
        size_t bit = y * bm->width + x;
        size_t word = bit / 32;
        size_t offset = bit % 32;
        bm->data[word] |= (1 << offset);
    }
}

int bitmap_get_pixel(Bitmap *bm, size_t x, size_t y) {
    if (x < bm->width && y < bm->height) {
        size_t bit = y * bm->width + x;
        size_t word = bit / 32;
        size_t offset = bit % 32;
        return (bm->data[word] >> offset) & 1;
    }
    return 0;
}

void bitmap_destroy(Bitmap *bm) {
    if (bm != NULL) {
        free(bm->data);
        free(bm);
    }
}

// 使用示例
int main() {
    Bitmap *bm = bitmap_create(8, 8);
    
    // 绘制一个简单的图案
    for (int i = 0; i < 8; i++) {
        bitmap_set_pixel(bm, i, i);  // 对角线
        bitmap_set_pixel(bm, i, 7 - i);  // 反对角线
    }
    
    // 打印位图
    printf("位图内容:\n");
    for (int y = 0; y < 8; y++) {
        for (int x = 0; x < 8; x++) {
            printf("%c ", bitmap_get_pixel(bm, x, y) ? 'X' : '.');
        }
        printf("\n");
    }
    
    bitmap_destroy(bm);
    
    return 0;
}
```

## 练习

1. 实现一个位集合的交集、并集、差集操作
2. 使用位操作实现一个简单的压缩算法
3. 实现一个位图字体渲染器
4. 编写函数检测整数中的连续1的序列

