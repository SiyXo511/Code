# C语言编译和链接详解

本教程将深入学习C语言的编译和链接过程，包括预处理、编译、汇编、链接等各个阶段。

## 1. 编译过程

### 编译的四个阶段

```
源代码(.c) → 预处理器 → 编译器 → 汇编器 → 链接器 → 可执行文件
```

#### 阶段1：预处理

```c
// source.c
#include <stdio.h>
#define MAX 100

int main() {
    printf("MAX = %d\n", MAX);
    return 0;
}

// 预处理命令: gcc -E source.c -o source.i
// 查看预处理后的代码: cat source.i
```

#### 阶段2：编译

```bash
# 编译成汇编代码
gcc -S source.c -o source.s

# 查看汇编代码
cat source.s
```

#### 阶段3：汇编

```bash
# 汇编成目标文件
gcc -c source.c -o source.o

# 查看目标文件信息
objdump -d source.o  # 反汇编
nm source.o          # 符号表
```

#### 阶段4：链接

```bash
# 链接成可执行文件
gcc source.o -o program

# 查看可执行文件
file program
ldd program  # 查看动态库依赖
```

## 2. 预处理阶段

### 预处理指令

```c
#include <stdio.h>

// 条件编译示例
#ifdef DEBUG
    #define LOG(msg) printf("[DEBUG] %s\n", msg)
#else
    #define LOG(msg) ((void)0)
#endif

#ifndef VERSION
    #define VERSION "1.0.0"
#endif

int main() {
    LOG("程序启动");
    printf("版本: %s\n", VERSION);
    return 0;
}

// 预处理查看
// gcc -E -DDEBUG program.c -o program.i
```

## 3. 链接过程

### 静态链接 vs 动态链接

#### 静态链接

```c
// math_utils.c
int add(int a, int b) {
    return a + b;
}

// 编译成静态库
// gcc -c math_utils.c -o math_utils.o
// ar rcs libmath.a math_utils.o

// main.c
// extern int add(int a, int b);

// 链接静态库
// gcc main.c -L. -lmath -o program
```

#### 动态链接

```c
// 编译成动态库
// gcc -shared -fPIC math_utils.c -o libmath.so

// 链接动态库
// gcc main.c -L. -lmath -o program

// 设置库路径
// export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
```

## 4. Makefile 详解

### 高级 Makefile

```makefile
# Makefile 高级示例

# 编译器设置
CC = gcc
CFLAGS = -Wall -Wextra -g -O2
LDFLAGS = -L. -lm
TARGET = myprogram

# 目录
SRC_DIR = src
OBJ_DIR = obj
INC_DIR = include

# 源文件和目标文件
SOURCES = $(wildcard $(SRC_DIR)/*.c)
OBJECTS = $(SOURCES:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)

# 包含目录
INCLUDES = -I$(INC_DIR)

# 默认目标
all: $(TARGET)

# 链接目标文件
$(TARGET): $(OBJECTS)
	$(CC) $(OBJECTS) -o $(TARGET) $(LDFLAGS)

# 编译源文件
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
	@mkdir -p $(OBJ_DIR)
	$(CC) $(CFLAGS) $(INCLUDES) -c $< -o $@

# 清理
clean:
	rm -rf $(OBJ_DIR) $(TARGET)

# 安装
install: $(TARGET)
	cp $(TARGET) /usr/local/bin/

# 卸载
uninstall:
	rm -f /usr/local/bin/$(TARGET)

# 声明伪目标
.PHONY: all clean install uninstall
```

## 5. 编译器选项

### GCC 常用选项

```bash
# 编译选项
gcc -c file.c          # 只编译，不链接
gcc -S file.c          # 生成汇编代码
gcc -E file.c          # 只预处理
gcc -o output file.c   # 指定输出文件名

# 警告选项
gcc -Wall file.c       # 启用所有警告
gcc -Wextra file.c     # 启用额外警告
gcc -Werror file.c     # 将警告视为错误
gcc -Wno-unused file.c # 禁用特定警告

# 优化选项
gcc -O0 file.c         # 无优化（调试用）
gcc -O1 file.c         # 基本优化
gcc -O2 file.c         # 推荐优化级别
gcc -O3 file.c         # 激进优化
gcc -Os file.c         # 优化代码大小

# 调试选项
gcc -g file.c          # 包含调试信息
gcc -ggdb file.c       # GDB格式调试信息
gcc -pg file.c         # 包含性能分析信息

# 链接选项
gcc -L/path/to/lib file.c -lmylib  # 指定库目录
gcc -static file.c     # 静态链接
gcc -shared file.c     # 生成共享库
gcc -fPIC file.c       # 位置无关代码

# 标准选项
gcc -std=c89 file.c    # C89标准
gcc -std=c99 file.c    # C99标准
gcc -std=c11 file.c    # C11标准
```

## 6. 符号表和链接

### 查看符号

```bash
# 查看目标文件符号
nm object.o

# 符号类型：
# T: 代码段（函数定义）
# U: 未定义（需要链接）
# D: 数据段（已初始化全局变量）
# B: BSS段（未初始化全局变量）
# C: 公共符号

# 查看符号详细信息
objdump -t object.o

# 查看依赖关系
ldd program

# 查看动态符号
nm -D libmylib.so
```

## 7. 链接脚本

### 简单的链接脚本

```ld
/* link.ld - 链接脚本示例 */

ENTRY(main)           /* 入口点 */

SECTIONS
{
    . = 0x10000;      /* 起始地址 */
    
    .text : {
        *(.text)      /* 代码段 */
    }
    
    .data : {
        *(.data)      /* 数据段 */
    }
    
    .bss : {
        *(.bss)       /* BSS段 */
    }
}

// 使用链接脚本
// gcc -T link.ld file.c -o program
```

## 8. 编译错误和警告

### 常见编译错误

```c
// 错误1：语法错误
// int x = 10;  // 缺少分号
int x = 10;

// 错误2：类型不匹配
// int *ptr = "Hello";  // 警告：类型不匹配
char *ptr = "Hello";

// 错误3：未声明的标识符
// printf("%d\n", undefined_var);  // 错误：未定义变量

// 错误4：重复定义
// int global_var = 10;
// int global_var = 20;  // 错误：重复定义

// 错误5：链接错误
// 函数声明和定义不匹配
// extern int add(int a, int b);  // 声明
// int add(double a, double b) { return a + b; }  // 定义不匹配
```

## 9. 调试信息

### 生成调试信息

```c
// debug_example.c
#include <stdio.h>

int main() {
    int x = 10;
    int y = 20;
    int sum = x + y;
    
    printf("x = %d, y = %d, sum = %d\n", x, y, sum);
    return 0;
}

// 编译带调试信息
// gcc -g debug_example.c -o debug_example

// 使用GDB调试
// gdb ./debug_example
// (gdb) break main
// (gdb) run
// (gdb) print x
// (gdb) step
// (gdb) continue
```

## 10. 性能分析

### 使用gprof

```c
// profile_example.c
#include <stdio.h>
#include <unistd.h>

void function1() {
    for (volatile int i = 0; i < 1000000; i++);
}

void function2() {
    for (volatile int i = 0; i < 2000000; i++);
}

int main() {
    function1();
    function2();
    return 0;
}

// 编译：gcc -pg -O2 profile_example.c -o profile_example
// 运行：./profile_example
// 分析：gprof profile_example gmon.out > analysis.txt
```

## 练习

1. 编写一个复杂的Makefile，支持多目录项目
2. 创建静态库和动态库，并测试链接
3. 使用链接脚本定制程序的内存布局
4. 分析编译过程中的各个阶段产生的文件

