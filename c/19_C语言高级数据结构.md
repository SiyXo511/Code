# C语言高级数据结构

本教程将学习C语言中常用的高级数据结构，包括链表、栈、队列、树、图、哈希表等。

## 1. 链表（Linked List）

### 单链表完整实现

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node *next;
} Node;

typedef struct {
    Node *head;
    int size;
} LinkedList;

// 创建链表
LinkedList* list_create() {
    LinkedList *list = (LinkedList *)malloc(sizeof(LinkedList));
    list->head = NULL;
    list->size = 0;
    return list;
}

// 在末尾添加节点
void list_append(LinkedList *list, int data) {
    Node *new_node = (Node *)malloc(sizeof(Node));
    new_node->data = data;
    new_node->next = NULL;
    
    if (list->head == NULL) {
        list->head = new_node;
    } else {
        Node *current = list->head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = new_node;
    }
    list->size++;
}

// 在开头插入节点
void list_prepend(LinkedList *list, int data) {
    Node *new_node = (Node *)malloc(sizeof(Node));
    new_node->data = data;
    new_node->next = list->head;
    list->head = new_node;
    list->size++;
}

// 删除节点
int list_remove(LinkedList *list, int data) {
    if (list->head == NULL) {
        return 0;
    }
    
    if (list->head->data == data) {
        Node *temp = list->head;
        list->head = list->head->next;
        free(temp);
        list->size--;
        return 1;
    }
    
    Node *current = list->head;
    while (current->next != NULL) {
        if (current->next->data == data) {
            Node *temp = current->next;
            current->next = current->next->next;
            free(temp);
            list->size--;
            return 1;
        }
        current = current->next;
    }
    
    return 0;
}

// 查找节点
Node* list_find(LinkedList *list, int data) {
    Node *current = list->head;
    while (current != NULL) {
        if (current->data == data) {
            return current;
        }
        current = current->next;
    }
    return NULL;
}

// 打印链表
void list_print(LinkedList *list) {
    Node *current = list->head;
    printf("链表内容: ");
    while (current != NULL) {
        printf("%d -> ", current->data);
        current = current->next;
    }
    printf("NULL\n");
}

// 销毁链表
void list_destroy(LinkedList *list) {
    Node *current = list->head;
    while (current != NULL) {
        Node *temp = current;
        current = current->next;
        free(temp);
    }
    free(list);
}

int main() {
    LinkedList *list = list_create();
    
    list_append(list, 10);
    list_append(list, 20);
    list_append(list, 30);
    list_prepend(list, 5);
    
    list_print(list);
    printf("链表大小: %d\n", list->size);
    
    list_remove(list, 20);
    list_print(list);
    
    Node *found = list_find(list, 30);
    if (found != NULL) {
        printf("找到节点: %d\n", found->data);
    }
    
    list_destroy(list);
    return 0;
}
```

### 双向链表

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct DNode {
    int data;
    struct DNode *prev;
    struct DNode *next;
} DNode;

typedef struct {
    DNode *head;
    DNode *tail;
    int size;
} DoublyLinkedList;

DoublyLinkedList* dlist_create() {
    DoublyLinkedList *list = (DoublyLinkedList *)malloc(sizeof(DoublyLinkedList));
    list->head = NULL;
    list->tail = NULL;
    list->size = 0;
    return list;
}

void dlist_append(DoublyLinkedList *list, int data) {
    DNode *new_node = (DNode *)malloc(sizeof(DNode));
    new_node->data = data;
    new_node->next = NULL;
    
    if (list->tail == NULL) {
        new_node->prev = NULL;
        list->head = new_node;
        list->tail = new_node;
    } else {
        new_node->prev = list->tail;
        list->tail->next = new_node;
        list->tail = new_node;
    }
    list->size++;
}

void dlist_print_forward(DoublyLinkedList *list) {
    DNode *current = list->head;
    printf("正向: ");
    while (current != NULL) {
        printf("%d <-> ", current->data);
        current = current->next;
    }
    printf("NULL\n");
}

void dlist_print_backward(DoublyLinkedList *list) {
    DNode *current = list->tail;
    printf("反向: ");
    while (current != NULL) {
        printf("%d <-> ", current->data);
        current = current->prev;
    }
    printf("NULL\n");
}

int main() {
    DoublyLinkedList *list = dlist_create();
    
    dlist_append(list, 10);
    dlist_append(list, 20);
    dlist_append(list, 30);
    
    dlist_print_forward(list);
    dlist_print_backward(list);
    
    return 0;
}
```

## 2. 树（Tree）

### 二叉树

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct TreeNode {
    int data;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// 创建节点
TreeNode* tree_create_node(int data) {
    TreeNode *node = (TreeNode *)malloc(sizeof(TreeNode));
    node->data = data;
    node->left = NULL;
    node->right = NULL;
    return node;
}

// 插入节点（二叉搜索树）
TreeNode* tree_insert(TreeNode *root, int data) {
    if (root == NULL) {
        return tree_create_node(data);
    }
    
    if (data < root->data) {
        root->left = tree_insert(root->left, data);
    } else if (data > root->data) {
        root->right = tree_insert(root->right, data);
    }
    
    return root;
}

// 前序遍历
void tree_preorder(TreeNode *root) {
    if (root != NULL) {
        printf("%d ", root->data);
        tree_preorder(root->left);
        tree_preorder(root->right);
    }
}

// 中序遍历
void tree_inorder(TreeNode *root) {
    if (root != NULL) {
        tree_inorder(root->left);
        printf("%d ", root->data);
        tree_inorder(root->right);
    }
}

// 后序遍历
void tree_postorder(TreeNode *root) {
    if (root != NULL) {
        tree_postorder(root->left);
        tree_postorder(root->right);
        printf("%d ", root->data);
    }
}

// 查找节点
TreeNode* tree_search(TreeNode *root, int data) {
    if (root == NULL || root->data == data) {
        return root;
    }
    
    if (data < root->data) {
        return tree_search(root->left, data);
    } else {
        return tree_search(root->right, data);
    }
}

// 计算树的高度
int tree_height(TreeNode *root) {
    if (root == NULL) {
        return -1;
    }
    
    int left_height = tree_height(root->left);
    int right_height = tree_height(root->right);
    
    return (left_height > right_height ? left_height : right_height) + 1;
}

// 销毁树
void tree_destroy(TreeNode *root) {
    if (root != NULL) {
        tree_destroy(root->left);
        tree_destroy(root->right);
        free(root);
    }
}

int main() {
    TreeNode *root = NULL;
    
    root = tree_insert(root, 50);
    tree_insert(root, 30);
    tree_insert(root, 70);
    tree_insert(root, 20);
    tree_insert(root, 40);
    tree_insert(root, 60);
    tree_insert(root, 80);
    
    printf("前序遍历: ");
    tree_preorder(root);
    printf("\n");
    
    printf("中序遍历: ");
    tree_inorder(root);
    printf("\n");
    
    printf("后序遍历: ");
    tree_postorder(root);
    printf("\n");
    
    printf("树的高度: %d\n", tree_height(root));
    
    TreeNode *found = tree_search(root, 40);
    if (found != NULL) {
        printf("找到节点: %d\n", found->data);
    }
    
    tree_destroy(root);
    return 0;
}
```

## 3. 哈希表（Hash Table）

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define HASH_TABLE_SIZE 100

typedef struct HashNode {
    char *key;
    int value;
    struct HashNode *next;
} HashNode;

typedef struct {
    HashNode **buckets;
    int size;
} HashTable;

// 哈希函数
unsigned int hash_function(const char *key, int table_size) {
    unsigned int hash = 0;
    while (*key) {
        hash = (hash * 31) + *key;
        key++;
    }
    return hash % table_size;
}

// 创建哈希表
HashTable* hash_table_create(int size) {
    HashTable *table = (HashTable *)malloc(sizeof(HashTable));
    table->buckets = (HashNode **)calloc(size, sizeof(HashNode *));
    table->size = size;
    return table;
}

// 插入键值对
void hash_table_insert(HashTable *table, const char *key, int value) {
    unsigned int index = hash_function(key, table->size);
    
    // 检查键是否已存在
    HashNode *current = table->buckets[index];
    while (current != NULL) {
        if (strcmp(current->key, key) == 0) {
            current->value = value;  // 更新值
            return;
        }
        current = current->next;
    }
    
    // 创建新节点
    HashNode *new_node = (HashNode *)malloc(sizeof(HashNode));
    new_node->key = strdup(key);
    new_node->value = value;
    new_node->next = table->buckets[index];
    table->buckets[index] = new_node;
}

// 查找值
int hash_table_get(HashTable *table, const char *key, int *value) {
    unsigned int index = hash_function(key, table->size);
    HashNode *current = table->buckets[index];
    
    while (current != NULL) {
        if (strcmp(current->key, key) == 0) {
            if (value != NULL) {
                *value = current->value;
            }
            return 1;  // 找到
        }
        current = current->next;
    }
    
    return 0;  // 未找到
}

// 删除键值对
int hash_table_remove(HashTable *table, const char *key) {
    unsigned int index = hash_function(key, table->size);
    HashNode *current = table->buckets[index];
    HashNode *prev = NULL;
    
    while (current != NULL) {
        if (strcmp(current->key, key) == 0) {
            if (prev == NULL) {
                table->buckets[index] = current->next;
            } else {
                prev->next = current->next;
            }
            free(current->key);
            free(current);
            return 1;  // 删除成功
        }
        prev = current;
        current = current->next;
    }
    
    return 0;  // 未找到
}

// 销毁哈希表
void hash_table_destroy(HashTable *table) {
    for (int i = 0; i < table->size; i++) {
        HashNode *current = table->buckets[i];
        while (current != NULL) {
            HashNode *temp = current;
            current = current->next;
            free(temp->key);
            free(temp);
        }
    }
    free(table->buckets);
    free(table);
}

int main() {
    HashTable *table = hash_table_create(HASH_TABLE_SIZE);
    
    hash_table_insert(table, "apple", 10);
    hash_table_insert(table, "banana", 20);
    hash_table_insert(table, "orange", 30);
    
    int value;
    if (hash_table_get(table, "apple", &value)) {
        printf("apple = %d\n", value);
    }
    
    hash_table_remove(table, "banana");
    
    if (!hash_table_get(table, "banana", NULL)) {
        printf("banana已删除\n");
    }
    
    hash_table_destroy(table);
    return 0;
}
```

## 4. 队列（Queue）

### 循环队列

```c
#include <stdio.h>
#include <stdlib.h>

#define QUEUE_SIZE 10

typedef struct {
    int *data;
    int front;
    int rear;
    int size;
    int capacity;
} CircularQueue;

CircularQueue* queue_create(int capacity) {
    CircularQueue *queue = (CircularQueue *)malloc(sizeof(CircularQueue));
    queue->data = (int *)malloc(capacity * sizeof(int));
    queue->front = 0;
    queue->rear = -1;
    queue->size = 0;
    queue->capacity = capacity;
    return queue;
}

int queue_is_empty(CircularQueue *queue) {
    return queue->size == 0;
}

int queue_is_full(CircularQueue *queue) {
    return queue->size == queue->capacity;
}

int queue_enqueue(CircularQueue *queue, int value) {
    if (queue_is_full(queue)) {
        return 0;  // 队列已满
    }
    
    queue->rear = (queue->rear + 1) % queue->capacity;
    queue->data[queue->rear] = value;
    queue->size++;
    return 1;
}

int queue_dequeue(CircularQueue *queue, int *value) {
    if (queue_is_empty(queue)) {
        return 0;  // 队列为空
    }
    
    if (value != NULL) {
        *value = queue->data[queue->front];
    }
    queue->front = (queue->front + 1) % queue->capacity;
    queue->size--;
    return 1;
}

void queue_destroy(CircularQueue *queue) {
    free(queue->data);
    free(queue);
}

int main() {
    CircularQueue *queue = queue_create(5);
    
    queue_enqueue(queue, 10);
    queue_enqueue(queue, 20);
    queue_enqueue(queue, 30);
    
    int value;
    while (!queue_is_empty(queue)) {
        queue_dequeue(queue, &value);
        printf("出队: %d\n", value);
    }
    
    queue_destroy(queue);
    return 0;
}
```

## 5. 优先队列（Priority Queue）

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_HEAP_SIZE 100

typedef struct {
    int *data;
    int size;
    int capacity;
} MaxHeap;

MaxHeap* heap_create(int capacity) {
    MaxHeap *heap = (MaxHeap *)malloc(sizeof(MaxHeap));
    heap->data = (int *)malloc((capacity + 1) * sizeof(int));
    heap->size = 0;
    heap->capacity = capacity;
    heap->data[0] = 0;  // 哨兵
    return heap;
}

void heap_up(MaxHeap *heap, int index) {
    int temp = heap->data[index];
    while (index > 1 && heap->data[index / 2] < temp) {
        heap->data[index] = heap->data[index / 2];
        index /= 2;
    }
    heap->data[index] = temp;
}

void heap_down(MaxHeap *heap, int index) {
    int temp = heap->data[index];
    int child;
    while (index * 2 <= heap->size) {
        child = index * 2;
        if (child != heap->size && heap->data[child + 1] > heap->data[child]) {
            child++;
        }
        if (heap->data[child] > temp) {
            heap->data[index] = heap->data[child];
            index = child;
        } else {
            break;
        }
    }
    heap->data[index] = temp;
}

void heap_push(MaxHeap *heap, int value) {
    if (heap->size >= heap->capacity) {
        return;
    }
    heap->data[++heap->size] = value;
    heap_up(heap, heap->size);
}

int heap_pop(MaxHeap *heap) {
    if (heap->size == 0) {
        return -1;
    }
    int max = heap->data[1];
    heap->data[1] = heap->data[heap->size--];
    heap_down(heap, 1);
    return max;
}

int main() {
    MaxHeap *heap = heap_create(10);
    
    heap_push(heap, 30);
    heap_push(heap, 10);
    heap_push(heap, 20);
    heap_push(heap, 50);
    heap_push(heap, 40);
    
    printf("优先队列（最大值优先）:\n");
    while (heap->size > 0) {
        printf("%d ", heap_pop(heap));
    }
    printf("\n");
    
    return 0;
}
```

## 练习

1. 实现一个完整的平衡二叉树（AVL树）
2. 实现一个图数据结构（邻接表或邻接矩阵）
3. 实现图的深度优先搜索（DFS）和广度优先搜索（BFS）
4. 实现一个Trie树（前缀树）用于字符串搜索

