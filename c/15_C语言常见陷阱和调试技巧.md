# C语言常见陷阱和调试技巧

本教程将学习C语言编程中的常见陷阱和调试技巧，帮助你避免错误并提高调试效率。

## 1. 常见陷阱

### 陷阱1：数组越界

```c
#include <stdio.h>

void array_bounds_example() {
    int arr[5] = {1, 2, 3, 4, 5};
    
    // 错误：访问越界（不会报错，但行为未定义）
    printf("arr[5] = %d\n", arr[5]);  // 危险！
    printf("arr[10] = %d\n", arr[10]);  // 危险！
    
    // 正确的做法：检查边界
    int index = 5;
    if (index >= 0 && index < 5) {
        printf("arr[%d] = %d\n", index, arr[index]);
    } else {
        printf("索引越界\n");
    }
}

// 防止越界的辅助宏
#define SAFE_ACCESS(arr, idx, size) \
    ((idx) >= 0 && (idx) < (size) ? arr[idx] : 0)

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    printf("安全访问: %d\n", SAFE_ACCESS(arr, 3, 5));
    printf("越界访问: %d\n", SAFE_ACCESS(arr, 10, 5));
    
    return 0;
}
```

### 陷阱2：未初始化的指针

```c
#include <stdio.h>
#include <stdlib.h>

void uninitialized_pointer() {
    int *ptr;  // 未初始化的指针
    
    // 错误：使用未初始化的指针（危险！）
    // *ptr = 10;  // 可能导致段错误
    
    // 正确的做法：初始化或分配内存
    int *ptr1 = NULL;  // 初始化为NULL
    if (ptr1 != NULL) {
        *ptr1 = 10;
    }
    
    // 或分配内存
    int *ptr2 = (int *)malloc(sizeof(int));
    if (ptr2 != NULL) {
        *ptr2 = 10;
        printf("值: %d\n", *ptr2);
        free(ptr2);
    }
}

// 安全的内存分配宏
#define SAFE_MALLOC(type, count) \
    ({ \
        type *ptr = (type *)malloc((count) * sizeof(type)); \
        if (ptr == NULL) { \
            fprintf(stderr, "内存分配失败\n"); \
            exit(EXIT_FAILURE); \
        } \
        ptr; \
    })

int main() {
    int *arr = SAFE_MALLOC(int, 10);
    for (int i = 0; i < 10; i++) {
        arr[i] = i;
    }
    free(arr);
    
    return 0;
}
```

### 陷阱3：内存泄漏

```c
#include <stdio.h>
#include <stdlib.h>

void memory_leak_example() {
    // 内存泄漏：分配后忘记释放
    int *ptr = (int *)malloc(sizeof(int));
    *ptr = 10;
    // 忘记free(ptr);  // 内存泄漏！
    
    // 正确的做法：配对使用malloc和free
    int *ptr2 = (int *)malloc(sizeof(int));
    if (ptr2 != NULL) {
        *ptr2 = 10;
        printf("值: %d\n", *ptr2);
        free(ptr2);  // 释放内存
        ptr2 = NULL;  // 防止野指针
    }
}

// 使用RAII模式（资源获取即初始化）
void safe_operation() {
    int *ptr = NULL;
    
    ptr = (int *)malloc(sizeof(int));
    if (ptr == NULL) {
        return;  // 错误处理
    }
    
    *ptr = 10;
    
    // 清理资源
    free(ptr);
    ptr = NULL;
}
```

### 陷阱4：悬空指针

```c
#include <stdio.h>
#include <stdlib.h>

int* create_int(int value) {
    int local = value;  // 局部变量
    return &local;  // 错误：返回局部变量地址！
}

// 正确的做法
int* create_int_correct(int value) {
    int *ptr = (int *)malloc(sizeof(int));
    if (ptr != NULL) {
        *ptr = value;
    }
    return ptr;
}

void dangling_pointer_example() {
    int *ptr = create_int(10);
    // ptr现在指向已释放的内存（悬空指针）
    // printf("*ptr = %d\n", *ptr);  // 危险！未定义行为
    
    // 正确的做法
    int *ptr2 = create_int_correct(10);
    if (ptr2 != NULL) {
        printf("*ptr2 = %d\n", *ptr2);
        free(ptr2);
    }
}

int main() {
    dangling_pointer_example();
    return 0;
}
```

### 陷阱5：整数溢出

```c
#include <stdio.h>
#include <limits.h>

void integer_overflow() {
    int max = INT_MAX;
    
    // 整数溢出（未定义行为）
    // int overflow = max + 1;  // 危险！
    
    // 检查溢出
    if (max < INT_MAX) {
        int safe = max + 1;
        printf("安全加法: %d\n", safe);
    } else {
        printf("溢出！\n");
    }
    
    // 使用更大的类型检查
    long long result = (long long)max + 1;
    if (result > INT_MAX) {
        printf("溢出！结果: %lld\n", result);
    }
}

// 安全的加法
int safe_add(int a, int b) {
    if (a > INT_MAX - b) {
        printf("加法溢出！\n");
        return INT_MAX;
    }
    return a + b;
}

int main() {
    printf("INT_MAX = %d\n", INT_MAX);
    safe_add(INT_MAX, 1);
    
    return 0;
}
```

## 2. 调试技巧

### 使用printf调试

```c
#include <stdio.h>
#include <stdlib.h>

// 调试宏
#ifdef DEBUG
    #define DBG_PRINT(fmt, ...) \
        printf("[DEBUG %s:%d] " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)
#else
    #define DBG_PRINT(fmt, ...) ((void)0)
#endif

void debug_example(int x, int y) {
    DBG_PRINT("函数开始: x = %d, y = %d", x, y);
    
    int sum = x + y;
    DBG_PRINT("计算sum: %d", sum);
    
    int product = x * y;
    DBG_PRINT("计算product: %d", product);
    
    printf("结果: %d + %d = %d, %d * %d = %d\n", 
           x, y, sum, x, y, product);
}

int main() {
    // 定义DEBUG启用调试输出
    #define DEBUG 1
    
    debug_example(5, 3);
    
    return 0;
}
```

### 使用GDB调试

```c
// gdb_example.c
#include <stdio.h>
#include <stdlib.h>

void factorial(int n) {
    int result = 1;
    
    for (int i = 1; i <= n; i++) {
        result *= i;  // 设置断点：b factorial
    }
    
    printf("%d! = %d\n", n, result);
}

int main() {
    factorial(5);
    return 0;
}

// 编译: gcc -g gdb_example.c -o gdb_example
// 调试: gdb ./gdb_example
// GDB命令:
//   break factorial    - 设置断点
//   run                - 运行程序
//   print result       - 打印变量
//   step               - 单步执行
//   next               - 下一行
//   continue           - 继续执行
//   backtrace          - 显示调用栈
//   quit               - 退出
```

### 使用Valgrind检测内存错误

```c
// valgrind_example.c
#include <stdio.h>
#include <stdlib.h>

void memory_error_example() {
    // 内存泄漏
    int *ptr1 = malloc(sizeof(int));
    *ptr1 = 10;
    // 忘记free(ptr1);
    
    // 使用已释放的内存
    int *ptr2 = malloc(sizeof(int));
    *ptr2 = 20;
    free(ptr2);
    // *ptr2 = 30;  // 使用已释放的内存
    
    // 重复释放
    int *ptr3 = malloc(sizeof(int));
    *ptr3 = 30;
    free(ptr3);
    // free(ptr3);  // 重复释放
}

// 编译: gcc -g valgrind_example.c -o valgrind_example
// 运行: valgrind --leak-check=full ./valgrind_example
```

### AddressSanitizer

```c
// asan_example.c
#include <stdio.h>
#include <stdlib.h>

void buffer_overflow() {
    int arr[5] = {1, 2, 3, 4, 5};
    arr[10] = 100;  // 缓冲区溢出
}

// 编译: gcc -fsanitize=address -g asan_example.c -o asan_example
// 运行: ./asan_example  (会自动检测内存错误)
```

## 3. 断言和验证

### assert宏

```c
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>

// 使用assert验证假设
int divide(int a, int b) {
    assert(b != 0);  // 断言：除数不能为0
    return a / b;
}

// 自定义断言
#define CUSTOM_ASSERT(condition, message) \
    do { \
        if (!(condition)) { \
            fprintf(stderr, "断言失败: %s\n", message); \
            fprintf(stderr, "文件: %s, 行: %d\n", __FILE__, __LINE__); \
            abort(); \
        } \
    } while(0)

void example_function(int *ptr, int size) {
    CUSTOM_ASSERT(ptr != NULL, "指针不能为NULL");
    CUSTOM_ASSERT(size > 0, "大小必须大于0");
    
    for (int i = 0; i < size; i++) {
        ptr[i] = i;
    }
}

int main() {
    // NDEBUG定义时会禁用assert
    // 编译: gcc -DNDEBUG program.c  (禁用断言)
    
    printf("10 / 2 = %d\n", divide(10, 2));
    
    int arr[10];
    example_function(arr, 10);
    
    return 0;
}
```

## 4. 常见错误模式

### 错误1：字符串操作错误

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void string_mistakes() {
    char str1[10];
    
    // 错误：缓冲区溢出
    // strcpy(str1, "This is a very long string");  // 危险！
    
    // 正确的做法：使用strncpy
    strncpy(str1, "Hello", sizeof(str1) - 1);
    str1[sizeof(str1) - 1] = '\0';
    
    // 或使用snprintf
    snprintf(str1, sizeof(str1), "Hello");
    
    // 字符串比较
    char *str2 = "Hello";
    // 错误：比较指针
    // if (str1 == str2)  // 总是false！
    
    // 正确：比较内容
    if (strcmp(str1, str2) == 0) {
        printf("字符串相等\n");
    }
}
```

### 错误2：循环中的变量

```c
#include <stdio.h>

void loop_mistakes() {
    int arr[5] = {1, 2, 3, 4, 5};
    
    // 错误：在循环中修改循环变量
    // for (int i = 0; i < 5; i++) {
    //     i = i * 2;  // 危险！
    // }
    
    // 正确的做法
    for (int i = 0; i < 5; i++) {
        int value = arr[i] * 2;
        printf("%d ", value);
    }
    printf("\n");
}

// 循环中的数组大小问题
void array_size_in_loop() {
    int arr[5] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);  // 正确获取大小
    
    // 在函数中传递数组时会丢失大小信息
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}
```

### 错误3：类型转换陷阱

```c
#include <stdio.h>
#include <stdint.h>

void type_conversion_mistakes() {
    // 有符号和无符号混用
    int a = -1;
    unsigned int b = 1;
    
    if (a < b) {
        printf("a < b\n");
    } else {
        printf("a >= b (因为a被转换为unsigned)\n");
    }
    
    // 指针和整数混用
    int *ptr = (int *)malloc(sizeof(int));
    intptr_t ptr_val = (intptr_t)ptr;  // 正确：使用intptr_t
    
    // 大小端问题
    uint16_t value = 0x1234;
    unsigned char *bytes = (unsigned char *)&value;
    printf("字节序: 0x%02x 0x%02x\n", bytes[0], bytes[1]);
}
```

## 5. 调试工具和技巧

### 使用strace追踪系统调用

```bash
# 追踪程序的所有系统调用
strace ./program

# 只追踪特定系统调用
strace -e trace=open,read,write ./program

# 统计系统调用
strace -c ./program
```

### 使用ltrace追踪库调用

```bash
# 追踪动态库函数调用
ltrace ./program

# 只追踪特定函数
ltrace -e malloc,free ./program
```

### 内存检查工具

```c
// 使用mcheck检查内存错误
#include <mcheck.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    mtrace();  // 启用内存追踪
    
    int *ptr = malloc(sizeof(int));
    *ptr = 10;
    free(ptr);
    
    muntrace();  // 关闭内存追踪
    
    return 0;
}

// 编译: gcc -g program.c -o program
// 运行: MALLOC_TRACE=log.txt ./program
// 分析: mtrace program log.txt
```

## 6. 防御性编程

### 输入验证

```c
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// 安全的输入函数
int safe_input_int(const char *prompt, int *result) {
    char buffer[256];
    long value;
    char *endptr;
    
    printf("%s", prompt);
    if (fgets(buffer, sizeof(buffer), stdin) == NULL) {
        return -1;
    }
    
    value = strtol(buffer, &endptr, 10);
    
    // 检查转换是否成功
    if (*endptr != '\n' && *endptr != '\0') {
        printf("无效输入\n");
        return -1;
    }
    
    // 检查范围
    if (value < INT_MIN || value > INT_MAX) {
        printf("数值超出范围\n");
        return -1;
    }
    
    *result = (int)value;
    return 0;
}

int main() {
    int value;
    if (safe_input_int("请输入一个整数: ", &value) == 0) {
        printf("输入值: %d\n", value);
    } else {
        printf("输入失败\n");
    }
    
    return 0;
}
```

### 资源管理宏

```c
#include <stdio.h>
#include <stdlib.h>

#define WITH_MALLOC(type, var, size, block) \
    do { \
        type *var = (type *)malloc((size) * sizeof(type)); \
        if (var != NULL) { \
            block \
            free(var); \
        } \
    } while(0)

#define WITH_FILE(filename, mode, var, block) \
    do { \
        FILE *var = fopen(filename, mode); \
        if (var != NULL) { \
            block \
            fclose(var); \
        } \
    } while(0)

int main() {
    WITH_MALLOC(int, arr, 10, {
        for (int i = 0; i < 10; i++) {
            arr[i] = i;
        }
        printf("数组创建成功\n");
        // 自动释放
    });
    
    WITH_FILE("test.txt", "w", file, {
        fprintf(file, "Hello, World!\n");
        printf("文件写入成功\n");
        // 自动关闭
    });
    
    return 0;
}
```

## 7. 静态分析工具

### 使用clang静态分析

```bash
# 静态分析
clang --analyze program.c

# 使用scan-build
scan-build gcc program.c
```

### 使用cppcheck

```bash
# 检查代码
cppcheck program.c

# 详细检查
cppcheck --enable=all program.c
```

## 练习

1. 编写一个测试套件，检测常见的内存错误
2. 使用GDB调试一个复杂程序，找出bug
3. 使用Valgrind检查一个项目中的内存泄漏
4. 实现一个内存分配器的包装，自动检测错误

