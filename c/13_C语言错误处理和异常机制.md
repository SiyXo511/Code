# C语言错误处理和异常机制

本教程将学习C语言中的错误处理机制，包括错误码、异常处理、信号处理等内容。

## 1. 错误码机制

### 返回值错误码

```c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

// 定义错误码
#define SUCCESS 0
#define ERROR_INVALID_INPUT -1
#define ERROR_MEMORY_ALLOCATION -2
#define ERROR_FILE_NOT_FOUND -3

// 返回错误码的函数
int divide(int a, int b, double *result) {
    if (result == NULL) {
        return ERROR_INVALID_INPUT;
    }
    
    if (b == 0) {
        return ERROR_INVALID_INPUT;  // 除零错误
    }
    
    *result = (double)a / b;
    return SUCCESS;
}

// 使用errno
int open_file(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        // errno自动设置
        fprintf(stderr, "错误: 无法打开文件 '%s': %s\n", 
                filename, strerror(errno));
        return ERROR_FILE_NOT_FOUND;
    }
    
    fclose(file);
    return SUCCESS;
}

int main() {
    double result;
    int err = divide(10, 3, &result);
    
    if (err == SUCCESS) {
        printf("结果: %.2f\n", result);
    } else {
        printf("错误码: %d\n", err);
    }
    
    // 测试errno
    err = open_file("nonexistent.txt");
    if (err != SUCCESS) {
        printf("文件操作失败\n");
    }
    
    return 0;
}
```

### 全局错误状态

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 全局错误信息
static char error_message[256] = {0};

const char* get_last_error() {
    return error_message;
}

void set_error(const char *format, ...) {
    va_list args;
    va_start(args, format);
    vsnprintf(error_message, sizeof(error_message), format, args);
    va_end(args);
}

int safe_divide(double a, double b, double *result) {
    if (result == NULL) {
        set_error("结果指针不能为NULL");
        return -1;
    }
    
    if (b == 0.0) {
        set_error("除数不能为0");
        return -1;
    }
    
    *result = a / b;
    error_message[0] = '\0';  // 清除错误信息
    return 0;
}

int main() {
    double result;
    
    if (safe_divide(10.0, 2.0, &result) == 0) {
        printf("结果: %.2f\n", result);
    } else {
        printf("错误: %s\n", get_last_error());
    }
    
    if (safe_divide(10.0, 0.0, &result) != 0) {
        printf("错误: %s\n", get_last_error());
    }
    
    return 0;
}
```

## 2. setjmp 和 longjmp

### 非局部跳转

```c
#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>
#include <string.h>

jmp_buf jump_buffer;

int divide_with_jump(double a, double b, double *result) {
    if (b == 0.0) {
        longjmp(jump_buffer, 1);  // 跳转到setjmp处，返回值为1
    }
    
    *result = a / b;
    return 0;
}

int main() {
    double result;
    int error_code = setjmp(jump_buffer);
    
    if (error_code == 0) {
        // 正常执行
        printf("尝试除法运算...\n");
        divide_with_jump(10.0, 2.0, &result);
        printf("结果: %.2f\n", result);
        
        printf("尝试除零...\n");
        divide_with_jump(10.0, 0.0, &result);
        printf("这行不会执行\n");
    } else {
        // 错误处理
        printf("发生错误！错误码: %d\n", error_code);
        printf("除数不能为0\n");
    }
    
    return 0;
}
```

### 嵌套错误处理

```c
#include <stdio.h>
#include <setjmp.h>

jmp_buf main_buffer;
jmp_buf nested_buffer;

void function1() {
    printf("进入function1\n");
    
    int error = setjmp(nested_buffer);
    if (error == 0) {
        printf("function1正常执行\n");
        // 模拟错误
        longjmp(main_buffer, 2);
    } else {
        printf("function1处理嵌套错误: %d\n", error);
    }
}

int main() {
    int error = setjmp(main_buffer);
    
    if (error == 0) {
        printf("main正常执行\n");
        function1();
        printf("这行不会执行\n");
    } else {
        printf("main处理错误: %d\n", error);
    }
    
    return 0;
}
```

## 3. 信号处理

### 信号基础

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

volatile sig_atomic_t keep_running = 1;

void signal_handler(int sig) {
    if (sig == SIGINT) {
        printf("\n收到SIGINT信号（Ctrl+C）\n");
        keep_running = 0;
    } else if (sig == SIGTERM) {
        printf("\n收到SIGTERM信号\n");
        keep_running = 0;
    }
}

int main() {
    // 注册信号处理函数
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    
    printf("程序运行中，按Ctrl+C退出...\n");
    
    while (keep_running) {
        printf("运行中...\n");
        sleep(1);
    }
    
    printf("程序正常退出\n");
    return 0;
}
```

### SIGSEGV 处理（段错误）

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <setjmp.h>

jmp_buf segv_buffer;

void segfault_handler(int sig) {
    if (sig == SIGSEGV) {
        printf("捕获段错误！\n");
        longjmp(segv_buffer, 1);
    }
}

void dangerous_function() {
    int *ptr = NULL;
    *ptr = 10;  // 这会引发段错误
}

int main() {
    signal(SIGSEGV, segfault_handler);
    
    if (setjmp(segv_buffer) == 0) {
        printf("调用危险函数...\n");
        dangerous_function();
        printf("这行不会执行\n");
    } else {
        printf("段错误已处理\n");
    }
    
    return 0;
}
```

## 4. 断言（Assertions）

### assert 宏

```c
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>

int divide_safe(int a, int b) {
    assert(b != 0);  // 断言：除数不能为0
    return a / b;
}

void allocate_memory(size_t size) {
    void *ptr = malloc(size);
    assert(ptr != NULL);  // 断言：内存分配必须成功
    // 使用内存...
    free(ptr);
}

// 自定义断言宏
#ifdef DEBUG
    #define CUSTOM_ASSERT(condition, message) \
        do { \
            if (!(condition)) { \
                fprintf(stderr, "断言失败: %s\n", message); \
                fprintf(stderr, "文件: %s, 行: %d\n", __FILE__, __LINE__); \
                abort(); \
            } \
        } while(0)
#else
    #define CUSTOM_ASSERT(condition, message) ((void)0)
#endif

int main() {
    printf("10 / 2 = %d\n", divide_safe(10, 2));
    
    // 以下会触发断言（在DEBUG模式下）
    // printf("10 / 0 = %d\n", divide_safe(10, 0));
    
    CUSTOM_ASSERT(1 == 1, "这不应该失败");
    
    return 0;
}
```

## 5. 资源清理（RAII模式模拟）

### 自动资源管理

```c
#include <stdio.h>
#include <stdlib.h>

// 资源句柄结构
typedef struct {
    FILE *file;
    int valid;
} FileHandle;

FileHandle* open_file_handle(const char *filename, const char *mode) {
    FileHandle *handle = (FileHandle *)malloc(sizeof(FileHandle));
    if (handle == NULL) {
        return NULL;
    }
    
    handle->file = fopen(filename, mode);
    handle->valid = (handle->file != NULL);
    
    return handle;
}

void close_file_handle(FileHandle *handle) {
    if (handle != NULL) {
        if (handle->valid && handle->file != NULL) {
            fclose(handle->file);
            handle->valid = 0;
        }
        free(handle);
    }
}

int main() {
    FileHandle *handle = open_file_handle("test.txt", "w");
    
    if (handle != NULL && handle->valid) {
        fprintf(handle->file, "Hello, World!\n");
        printf("文件写入成功\n");
    }
    
    close_file_handle(handle);  // 确保资源释放
    
    return 0;
}
```

### 使用宏简化资源管理

```c
#include <stdio.h>
#include <stdlib.h>

#define FILE_HANDLE(name, filename, mode) \
    FileHandle *name = open_file_handle(filename, mode); \
    if (name == NULL || !name->valid) { \
        fprintf(stderr, "无法打开文件\n"); \
        goto cleanup_##name; \
    }

#define CLEANUP_FILE_HANDLE(name) \
    cleanup_##name: \
    close_file_handle(name);

int main() {
    FILE_HANDLE(file1, "file1.txt", "w")
    FILE_HANDLE(file2, "file2.txt", "w")
    
    fprintf(file1->file, "File 1 content\n");
    fprintf(file2->file, "File 2 content\n");
    
    CLEANUP_FILE_HANDLE(file1)
    CLEANUP_FILE_HANDLE(file2)
    
    return 0;
}
```

## 6. 异常处理宏

### 错误处理宏系统

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TRY do { \
    int error_code = 0;

#define CATCH(exception) \
    } while (0); \
    if (error_code != 0) { \
        if (error_code == exception) {

#define END_CATCH \
        } \
    }

#define THROW(code) \
    do { \
        error_code = code; \
        goto cleanup; \
    } while (0)

#define ERROR_INVALID_INPUT 1
#define ERROR_MEMORY 2
#define ERROR_FILE 3

int example_function() {
    TRY {
        int *ptr = malloc(100);
        if (ptr == NULL) {
            THROW(ERROR_MEMORY);
        }
        
        // 使用ptr...
        free(ptr);
        
        return 0;
    }
    CATCH(ERROR_MEMORY) {
        printf("内存分配失败\n");
        return -1;
    }
    END_CATCH
    
    cleanup:
    return -1;
}
```

## 7. 错误日志系统

### 日志记录

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <time.h>
#include <string.h>

typedef enum {
    LOG_DEBUG,
    LOG_INFO,
    LOG_WARNING,
    LOG_ERROR,
    LOG_CRITICAL
} LogLevel;

const char* log_level_strings[] = {
    "DEBUG",
    "INFO",
    "WARNING",
    "ERROR",
    "CRITICAL"
};

void log_message(LogLevel level, const char *file, int line, 
                 const char *format, ...) {
    time_t now;
    time(&now);
    struct tm *timeinfo = localtime(&now);
    
    char timestamp[64];
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", timeinfo);
    
    const char *filename = strrchr(file, '/');
    filename = filename ? filename + 1 : file;
    
    fprintf(stderr, "[%s] [%s] [%s:%d] ", 
            timestamp, log_level_strings[level], filename, line);
    
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    
    fprintf(stderr, "\n");
}

#define LOG_DEBUG(msg, ...) log_message(LOG_DEBUG, __FILE__, __LINE__, msg, ##__VA_ARGS__)
#define LOG_INFO(msg, ...) log_message(LOG_INFO, __FILE__, __LINE__, msg, ##__VA_ARGS__)
#define LOG_WARNING(msg, ...) log_message(LOG_WARNING, __FILE__, __LINE__, msg, ##__VA_ARGS__)
#define LOG_ERROR(msg, ...) log_message(LOG_ERROR, __FILE__, __LINE__, msg, ##__VA_ARGS__)
#define LOG_CRITICAL(msg, ...) log_message(LOG_CRITICAL, __FILE__, __LINE__, msg, ##__VA_ARGS__)

int main() {
    LOG_INFO("程序启动");
    LOG_DEBUG("调试信息: x = %d", 10);
    LOG_WARNING("这是一个警告");
    LOG_ERROR("这是一个错误: %s", "文件未找到");
    
    return 0;
}
```

## 8. 综合示例

### 完整的错误处理系统

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

typedef struct {
    int code;
    char message[256];
} Error;

Error last_error = {0, ""};

void set_error(int code, const char *format, ...) {
    va_list args;
    va_start(args, format);
    last_error.code = code;
    vsnprintf(last_error.message, sizeof(last_error.message), format, args);
    va_end(args);
}

Error get_last_error() {
    return last_error;
}

int safe_divide(double a, double b, double *result) {
    if (result == NULL) {
        set_error(-1, "结果指针不能为NULL");
        return -1;
    }
    
    if (b == 0.0) {
        set_error(-2, "除数不能为0");
        return -1;
    }
    
    *result = a / b;
    return 0;
}

int safe_open_file(const char *filename, const char *mode, FILE **file) {
    if (file == NULL) {
        set_error(-3, "文件指针参数无效");
        return -1;
    }
    
    *file = fopen(filename, mode);
    if (*file == NULL) {
        set_error(errno, "无法打开文件 '%s': %s", filename, strerror(errno));
        return -1;
    }
    
    return 0;
}

int main() {
    double result;
    
    if (safe_divide(10.0, 3.0, &result) == 0) {
        printf("结果: %.2f\n", result);
    } else {
        Error err = get_last_error();
        printf("错误 [%d]: %s\n", err.code, err.message);
    }
    
    FILE *file;
    if (safe_open_file("test.txt", "r", &file) == 0) {
        printf("文件打开成功\n");
        fclose(file);
    } else {
        Error err = get_last_error();
        printf("错误 [%d]: %s\n", err.code, err.message);
    }
    
    return 0;
}
```

## 练习

1. 实现一个完整的错误处理库，支持错误码、错误消息、错误链
2. 使用setjmp/longjmp实现一个简单的异常处理系统
3. 创建一个日志系统，支持不同级别的日志输出到不同文件
4. 实现资源管理宏，确保资源自动释放

