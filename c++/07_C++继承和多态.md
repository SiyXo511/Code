# C++继承和多态

本教程将学习C++中的继承和多态，包括继承基础、虚函数、抽象类、多重继承等。

## 1. 继承基础

### 单继承

```cpp
#include <iostream>
#include <string>
using namespace std;

// 基类
class Animal {
protected:
    string name;
    int age;
    
public:
    Animal(string n, int a) : name(n), age(a) {}
    
    void eat() {
        cout << name << " 正在吃东西" << endl;
    }
    
    void sleep() {
        cout << name << " 正在睡觉" << endl;
    }
    
    void display() {
        cout << "名称: " << name << ", 年龄: " << age << endl;
    }
};

// 派生类
class Dog : public Animal {
private:
    string breed;
    
public:
    // 派生类构造函数
    Dog(string n, int a, string b) : Animal(n, a), breed(b) {}
    
    // 新增功能
    void bark() {
        cout << name << " 在叫: 汪汪！" << endl;
    }
    
    // 重写基类方法
    void display() {
        Animal::display();  // 调用基类方法
        cout << "品种: " << breed << endl;
    }
};

int main() {
    Dog dog("旺财", 3, "金毛");
    dog.eat();      // 继承自基类
    dog.sleep();    // 继承自基类
    dog.bark();     // 派生类新方法
    dog.display();  // 重写的display方法
    
    return 0;
}
```

### 继承方式

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int public_member;
protected:
    int protected_member;
private:
    int private_member;
};

// public继承
class PublicDerived : public Base {
public:
    void test() {
        public_member = 1;      // 可以访问
        protected_member = 2;   // 可以访问
        // private_member = 3;  // 错误：不能访问
    }
};

// protected继承
class ProtectedDerived : protected Base {
public:
    void test() {
        public_member = 1;      // 变成protected
        protected_member = 2;   // 保持protected
    }
};

// private继承
class PrivateDerived : private Base {
public:
    void test() {
        public_member = 1;      // 变成private
        protected_member = 2;   // 变成private
    }
};

int main() {
    PublicDerived pub;
    pub.public_member = 10;  // 可以访问
    
    ProtectedDerived pro;
    // pro.public_member = 10;  // 错误：不能访问（变成protected）
    
    PrivateDerived pri;
    // pri.public_member = 10;  // 错误：不能访问（变成private）
    
    return 0;
}
```

## 2. 虚函数和多态

### 虚函数

```cpp
#include <iostream>
using namespace std;

class Shape {
protected:
    string name;
    
public:
    Shape(string n) : name(n) {}
    
    // 虚函数
    virtual void draw() {
        cout << "绘制 " << name << endl;
    }
    
    // 虚析构函数（重要！）
    virtual ~Shape() {
        cout << "Shape析构函数" << endl;
    }
};

class Circle : public Shape {
private:
    double radius;
    
public:
    Circle(string n, double r) : Shape(n), radius(r) {}
    
    // 重写虚函数
    void draw() override {  // C++11: override关键字
        cout << "绘制圆形 " << name << "，半径: " << radius << endl;
    }
    
    ~Circle() {
        cout << "Circle析构函数" << endl;
    }
};

class Rectangle : public Shape {
private:
    double width, height;
    
public:
    Rectangle(string n, double w, double h) 
        : Shape(n), width(w), height(h) {}
    
    void draw() override {
        cout << "绘制矩形 " << name 
             << "，宽度: " << width << "，高度: " << height << endl;
    }
    
    ~Rectangle() {
        cout << "Rectangle析构函数" << endl;
    }
};

int main() {
    // 多态：基类指针指向派生类对象
    Shape* shape1 = new Circle("圆形1", 5.0);
    Shape* shape2 = new Rectangle("矩形1", 10.0, 8.0);
    
    // 调用派生类的draw方法
    shape1->draw();  // 绘制圆形
    shape2->draw();  // 绘制矩形
    
    // 如果没有virtual关键字，这里会调用基类的draw方法
    
    delete shape1;
    delete shape2;
    
    return 0;
}
```

### 多态示例

```cpp
#include <iostream>
#include <vector>
#include <memory>
using namespace std;

class Animal {
public:
    virtual void makeSound() {
        cout << "动物发出声音" << endl;
    }
    
    virtual ~Animal() {}
};

class Dog : public Animal {
public:
    void makeSound() override {
        cout << "汪汪！" << endl;
    }
};

class Cat : public Animal {
public:
    void makeSound() override {
        cout << "喵喵！" << endl;
    }
};

int main() {
    vector<unique_ptr<Animal>> animals;
    
    animals.push_back(make_unique<Dog>());
    animals.push_back(make_unique<Cat>());
    
    // 多态调用
    for (auto& animal : animals) {
        animal->makeSound();  // 根据实际类型调用
    }
    
    return 0;
}
```

## 3. 纯虚函数和抽象类

```cpp
#include <iostream>
using namespace std;

// 抽象类：包含纯虚函数
class Shape {
protected:
    string name;
    
public:
    Shape(string n) : name(n) {}
    
    // 纯虚函数：派生类必须实现
    virtual double area() = 0;
    virtual double perimeter() = 0;
    
    // 可以有非纯虚函数
    virtual void display() {
        cout << "形状: " << name << endl;
    }
    
    virtual ~Shape() {}
};

class Circle : public Shape {
private:
    double radius;
    
public:
    Circle(string n, double r) : Shape(n), radius(r) {}
    
    // 必须实现纯虚函数
    double area() override {
        return 3.14159 * radius * radius;
    }
    
    double perimeter() override {
        return 2 * 3.14159 * radius;
    }
    
    void display() override {
        Shape::display();
        cout << "半径: " << radius << endl;
        cout << "面积: " << area() << endl;
        cout << "周长: " << perimeter() << endl;
    }
};

class Rectangle : public Shape {
private:
    double width, height;
    
public:
    Rectangle(string n, double w, double h) 
        : Shape(n), width(w), height(h) {}
    
    double area() override {
        return width * height;
    }
    
    double perimeter() override {
        return 2 * (width + height);
    }
    
    void display() override {
        Shape::display();
        cout << "宽度: " << width << "，高度: " << height << endl;
        cout << "面积: " << area() << endl;
        cout << "周长: " << perimeter() << endl;
    }
};

int main() {
    // Shape shape("抽象形状");  // 错误：不能实例化抽象类
    
    Circle circle("圆形", 5.0);
    Rectangle rect("矩形", 10.0, 8.0);
    
    circle.display();
    cout << endl;
    rect.display();
    
    // 使用指针实现多态
    Shape* shapes[] = {&circle, &rect};
    for (Shape* shape : shapes) {
        shape->display();
        cout << endl;
    }
    
    return 0;
}
```

## 4. 多重继承

```cpp
#include <iostream>
using namespace std;

class Flyable {
public:
    virtual void fly() = 0;
    virtual ~Flyable() {}
};

class Swimmable {
public:
    virtual void swim() = 0;
    virtual ~Swimmable() {}
};

class Bird : public Flyable {
public:
    void fly() override {
        cout << "鸟在飞" << endl;
    }
};

class Fish : public Swimmable {
public:
    void swim() override {
        cout << "鱼在游" << endl;
    }
};

// 多重继承
class Duck : public Flyable, public Swimmable {
public:
    void fly() override {
        cout << "鸭子在飞" << endl;
    }
    
    void swim() override {
        cout << "鸭子在游" << endl;
    }
};

int main() {
    Duck duck;
    duck.fly();
    duck.swim();
    
    return 0;
}
```

## 5. 菱形继承问题

```cpp
#include <iostream>
using namespace std;

// 基类
class Animal {
protected:
    string name;
    
public:
    Animal(string n) : name(n) {
        cout << "Animal构造函数" << endl;
    }
    
    virtual void eat() {
        cout << name << " 在吃东西" << endl;
    }
    
    virtual ~Animal() {
        cout << "Animal析构函数" << endl;
    }
};

// 派生类1
class Mammal : public Animal {
public:
    Mammal(string n) : Animal(n) {
        cout << "Mammal构造函数" << endl;
    }
    
    void breathe() {
        cout << name << " 在用肺呼吸" << endl;
    }
};

// 派生类2
class Winged : public Animal {
public:
    Winged(string n) : Animal(n) {
        cout << "Winged构造函数" << endl;
    }
    
    void fly() {
        cout << name << " 在飞" << endl;
    }
};

// 菱形继承：Bat继承自Mammal和Winged
class Bat : public Mammal, public Winged {
public:
    // 使用虚继承解决菱形继承问题
    Bat(string n) : Animal(n), Mammal(n), Winged(n) {
        cout << "Bat构造函数" << endl;
    }
    
    // 如果没有虚继承，这里会有二义性
    void eat() override {
        cout << name << " 蝙蝠在吃水果" << endl;
    }
};

// 使用虚继承
class Mammal2 : virtual public Animal {
public:
    Mammal2(string n) : Animal(n) {}
};

class Winged2 : virtual public Animal {
public:
    Winged2(string n) : Animal(n) {}
};

class Bat2 : public Mammal2, public Winged2 {
public:
    Bat2(string n) : Animal(n), Mammal2(n), Winged2(n) {}
    
    void eat() override {
        cout << name << " 蝙蝠在吃水果" << endl;
    }
};

int main() {
    cout << "=== 普通继承 ===" << endl;
    Bat bat("蝙蝠");
    bat.eat();
    bat.breathe();
    bat.fly();
    
    cout << "\n=== 虚继承 ===" << endl;
    Bat2 bat2("蝙蝠2");
    bat2.eat();
    
    return 0;
}
```

## 6. 虚函数表（VTable）

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void func1() {
        cout << "Base::func1()" << endl;
    }
    
    virtual void func2() {
        cout << "Base::func2()" << endl;
    }
};

class Derived : public Base {
public:
    void func1() override {
        cout << "Derived::func1()" << endl;
    }
    
    void func2() override {
        cout << "Derived::func2()" << endl;
    }
    
    virtual void func3() {
        cout << "Derived::func3()" << endl;
    }
};

int main() {
    Base base;
    Derived derived;
    
    Base* ptr = &derived;
    ptr->func1();  // 调用Derived::func1()
    ptr->func2();  // 调用Derived::func2()
    // ptr->func3();  // 错误：Base没有func3()
    
    return 0;
}
```

## 练习

1. 创建一个Vehicle基类，派生出Car和Bicycle类
2. 实现一个Employee基类，派生出Manager和Developer类
3. 使用多态实现一个图形绘制系统（Circle、Rectangle、Triangle）
4. 实现一个动物类的继承体系，使用虚函数实现多态
5. 解决多重继承中的菱形继承问题

