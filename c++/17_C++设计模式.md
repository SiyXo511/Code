# C++设计模式

本教程将学习C++中的常用设计模式，包括单例、工厂、观察者、策略、适配器等模式。

## 1. 单例模式（Singleton）

### 线程安全的单例

```cpp
#include <iostream>
#include <mutex>
using namespace std;

class Singleton {
private:
    static Singleton* instance;
    static mutex mtx;
    
    // 私有构造函数
    Singleton() {
        cout << "单例创建" << endl;
    }
    
    // 禁止拷贝
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    
public:
    static Singleton* getInstance() {
        if (instance == nullptr) {
            lock_guard<mutex> lock(mtx);
            if (instance == nullptr) {  // 双重检查
                instance = new Singleton();
            }
        }
        return instance;
    }
    
    void doSomething() {
        cout << "单例执行操作" << endl;
    }
    
    ~Singleton() {
        cout << "单例销毁" << endl;
    }
};

// 静态成员初始化
Singleton* Singleton::instance = nullptr;
mutex Singleton::mtx;

int main() {
    Singleton* s1 = Singleton::getInstance();
    Singleton* s2 = Singleton::getInstance();
    
    cout << "s1地址: " << s1 << endl;
    cout << "s2地址: " << s2 << endl;
    cout << "是否为同一实例: " << (s1 == s2 ? "是" : "否") << endl;
    
    s1->doSomething();
    
    return 0;
}
```

### C++11/14改进版

```cpp
#include <iostream>
using namespace std;

class Singleton {
private:
    Singleton() = default;
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    
public:
    static Singleton& getInstance() {
        static Singleton instance;  // 线程安全（C++11保证）
        return instance;
    }
    
    void doSomething() {
        cout << "单例操作" << endl;
    }
};

int main() {
    Singleton& s1 = Singleton::getInstance();
    Singleton& s2 = Singleton::getInstance();
    
    s1.doSomething();
    s2.doSomething();
    
    return 0;
}
```

## 2. 工厂模式（Factory）

### 简单工厂

```cpp
#include <iostream>
#include <string>
#include <memory>
using namespace std;

// 产品接口
class Shape {
public:
    virtual ~Shape() = default;
    virtual void draw() = 0;
};

// 具体产品
class Circle : public Shape {
public:
    void draw() override {
        cout << "绘制圆形" << endl;
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        cout << "绘制矩形" << endl;
    }
};

// 工厂类
class ShapeFactory {
public:
    static unique_ptr<Shape> createShape(const string& type) {
        if (type == "Circle") {
            return make_unique<Circle>();
        } else if (type == "Rectangle") {
            return make_unique<Rectangle>();
        }
        return nullptr;
    }
};

int main() {
    auto shape1 = ShapeFactory::createShape("Circle");
    auto shape2 = ShapeFactory::createShape("Rectangle");
    
    shape1->draw();
    shape2->draw();
    
    return 0;
}
```

### 抽象工厂

```cpp
#include <iostream>
#include <memory>
using namespace std;

// 产品族
class Button {
public:
    virtual void render() = 0;
};

class WindowsButton : public Button {
public:
    void render() override {
        cout << "Windows风格按钮" << endl;
    }
};

class LinuxButton : public Button {
public:
    void render() override {
        cout << "Linux风格按钮" << endl;
    }
};

class Window {
public:
    virtual void render() = 0;
};

class WindowsWindow : public Window {
public:
    void render() override {
        cout << "Windows风格窗口" << endl;
    }
};

class LinuxWindow : public Window {
public:
    void render() override {
        cout << "Linux风格窗口" << endl;
    }
};

// 抽象工厂
class UIFactory {
public:
    virtual unique_ptr<Button> createButton() = 0;
    virtual unique_ptr<Window> createWindow() = 0;
};

// 具体工厂
class WindowsFactory : public UIFactory {
public:
    unique_ptr<Button> createButton() override {
        return make_unique<WindowsButton>();
    }
    
    unique_ptr<Window> createWindow() override {
        return make_unique<WindowsWindow>();
    }
};

class LinuxFactory : public UIFactory {
public:
    unique_ptr<Button> createButton() override {
        return make_unique<LinuxButton>();
    }
    
    unique_ptr<Window> createWindow() override {
        return make_unique<LinuxWindow>();
    }
};

int main() {
    unique_ptr<UIFactory> factory = make_unique<WindowsFactory>();
    
    auto button = factory->createButton();
    auto window = factory->createWindow();
    
    button->render();
    window->render();
    
    return 0;
}
```

## 3. 观察者模式（Observer）

```cpp
#include <iostream>
#include <vector>
#include <memory>
#include <algorithm>
using namespace std;

// 观察者接口
class Observer {
public:
    virtual ~Observer() = default;
    virtual void update(const string& message) = 0;
};

// 主题接口
class Subject {
protected:
    vector<Observer*> observers;
    
public:
    void attach(Observer* observer) {
        observers.push_back(observer);
    }
    
    void detach(Observer* observer) {
        observers.erase(
            remove(observers.begin(), observers.end(), observer),
            observers.end()
        );
    }
    
    void notify(const string& message) {
        for (Observer* obs : observers) {
            obs->update(message);
        }
    }
};

// 具体观察者
class ConcreteObserver : public Observer {
private:
    string name;
    
public:
    ConcreteObserver(const string& n) : name(n) {}
    
    void update(const string& message) override {
        cout << name << " 收到消息: " << message << endl;
    }
};

// 具体主题
class ConcreteSubject : public Subject {
private:
    string state;
    
public:
    void setState(const string& s) {
        state = s;
        notify(state);  // 状态改变时通知观察者
    }
    
    string getState() const {
        return state;
    }
};

int main() {
    ConcreteSubject subject;
    
    ConcreteObserver obs1("观察者1");
    ConcreteObserver obs2("观察者2");
    ConcreteObserver obs3("观察者3");
    
    subject.attach(&obs1);
    subject.attach(&obs2);
    subject.attach(&obs3);
    
    subject.setState("状态已更新");
    
    subject.detach(&obs2);
    subject.setState("再次更新");
    
    return 0;
}
```

## 4. 策略模式（Strategy）

```cpp
#include <iostream>
#include <memory>
using namespace std;

// 策略接口
class SortStrategy {
public:
    virtual ~SortStrategy() = default;
    virtual void sort(vector<int>& data) = 0;
};

// 具体策略：冒泡排序
class BubbleSort : public SortStrategy {
public:
    void sort(vector<int>& data) override {
        cout << "使用冒泡排序" << endl;
        // 简化的冒泡排序
        for (size_t i = 0; i < data.size(); i++) {
            for (size_t j = 0; j < data.size() - i - 1; j++) {
                if (data[j] > data[j + 1]) {
                    swap(data[j], data[j + 1]);
                }
            }
        }
    }
};

// 具体策略：快速排序
class QuickSort : public SortStrategy {
public:
    void sort(vector<int>& data) override {
        cout << "使用快速排序" << endl;
        // 简化的快速排序（实际应使用标准库sort）
        std::sort(data.begin(), data.end());
    }
};

// 上下文
class Sorter {
private:
    unique_ptr<SortStrategy> strategy;
    
public:
    void setStrategy(unique_ptr<SortStrategy> s) {
        strategy = move(s);
    }
    
    void executeSort(vector<int>& data) {
        if (strategy) {
            strategy->sort(data);
        }
    }
};

int main() {
    vector<int> data{5, 2, 8, 1, 9, 3};
    
    Sorter sorter;
    
    // 使用冒泡排序
    sorter.setStrategy(make_unique<BubbleSort>());
    sorter.executeSort(data);
    
    data = {5, 2, 8, 1, 9, 3};  // 重置数据
    
    // 使用快速排序
    sorter.setStrategy(make_unique<QuickSort>());
    sorter.executeSort(data);
    
    return 0;
}
```

## 5. 适配器模式（Adapter）

```cpp
#include <iostream>
using namespace std;

// 目标接口
class Target {
public:
    virtual void request() = 0;
};

// 需要适配的类
class Adaptee {
public:
    void specificRequest() {
        cout << "适配者的特殊请求" << endl;
    }
};

// 适配器
class Adapter : public Target {
private:
    Adaptee* adaptee;
    
public:
    Adapter(Adaptee* a) : adaptee(a) {}
    
    void request() override {
        adaptee->specificRequest();  // 调用适配者的方法
    }
};

int main() {
    Adaptee adaptee;
    Adapter adapter(&adaptee);
    
    Target* target = &adapter;
    target->request();
    
    return 0;
}
```

## 6. 装饰器模式（Decorator）

```cpp
#include <iostream>
#include <memory>
#include <string>
using namespace std;

// 组件接口
class Component {
public:
    virtual ~Component() = default;
    virtual string operation() = 0;
};

// 具体组件
class ConcreteComponent : public Component {
public:
    string operation() override {
        return "具体组件";
    }
};

// 装饰器基类
class Decorator : public Component {
protected:
    unique_ptr<Component> component;
    
public:
    Decorator(unique_ptr<Component> comp) : component(move(comp)) {}
    
    string operation() override {
        return component->operation();
    }
};

// 具体装饰器
class ConcreteDecoratorA : public Decorator {
public:
    ConcreteDecoratorA(unique_ptr<Component> comp) 
        : Decorator(move(comp)) {}
    
    string operation() override {
        return "装饰器A(" + Decorator::operation() + ")";
    }
};

class ConcreteDecoratorB : public Decorator {
public:
    ConcreteDecoratorB(unique_ptr<Component> comp) 
        : Decorator(move(comp)) {}
    
    string operation() override {
        return "装饰器B(" + Decorator::operation() + ")";
    }
};

int main() {
    auto component = make_unique<ConcreteComponent>();
    auto decoratorA = make_unique<ConcreteDecoratorA>(move(component));
    auto decoratorB = make_unique<ConcreteDecoratorB>(move(decoratorA));
    
    cout << decoratorB->operation() << endl;
    
    return 0;
}
```

## 7. 命令模式（Command）

```cpp
#include <iostream>
#include <vector>
#include <memory>
using namespace std;

// 命令接口
class Command {
public:
    virtual ~Command() = default;
    virtual void execute() = 0;
    virtual void undo() = 0;
};

// 接收者
class Receiver {
private:
    int value = 0;
    
public:
    void add(int x) {
        value += x;
        cout << "值变为: " << value << endl;
    }
    
    void subtract(int x) {
        value -= x;
        cout << "值变为: " << value << endl;
    }
    
    int getValue() const {
        return value;
    }
};

// 具体命令
class AddCommand : public Command {
private:
    Receiver* receiver;
    int amount;
    
public:
    AddCommand(Receiver* r, int a) : receiver(r), amount(a) {}
    
    void execute() override {
        receiver->add(amount);
    }
    
    void undo() override {
        receiver->subtract(amount);
    }
};

// 调用者
class Invoker {
private:
    vector<unique_ptr<Command>> commands;
    
public:
    void executeCommand(unique_ptr<Command> cmd) {
        cmd->execute();
        commands.push_back(move(cmd));
    }
    
    void undo() {
        if (!commands.empty()) {
            commands.back()->undo();
            commands.pop_back();
        }
    }
};

int main() {
    Receiver receiver;
    Invoker invoker;
    
    invoker.executeCommand(make_unique<AddCommand>(&receiver, 10));
    invoker.executeCommand(make_unique<AddCommand>(&receiver, 5));
    
    invoker.undo();
    invoker.undo();
    
    return 0;
}
```

## 练习

1. 实现一个线程安全的单例日志类
2. 使用工厂模式创建一个图形库
3. 实现一个完整的事件系统（观察者模式）
4. 使用策略模式实现多种排序算法
5. 实现一个命令模式的撤销/重做系统

