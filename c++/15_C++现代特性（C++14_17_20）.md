# C++现代特性（C++14/17/20）

本教程将学习C++14、C++17和C++20引入的新特性。

## 1. C++14特性

### 泛型Lambda

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // C++14: 泛型Lambda（auto参数）
    auto print = [](auto value) {
        cout << value << endl;
    };
    
    print(10);
    print(3.14);
    print("Hello");
    
    // 多个泛型参数
    auto add = [](auto a, auto b) {
        return a + b;
    };
    
    cout << add(10, 20) << endl;
    cout << add(3.14, 2.71) << endl;
    
    return 0;
}
```

### 变量模板（C++14）

```cpp
#include <iostream>
using namespace std;

// 变量模板
template<typename T>
constexpr T pi = T(3.1415926535897932385L);

int main() {
    cout << pi<int> << endl;      // 3
    cout << pi<float> << endl;    // 3.14159
    cout << pi<double> << endl;   // 3.14159
    
    return 0;
}
```

### make_unique

```cpp
#include <memory>
using namespace std;

int main() {
    // C++14: make_unique
    auto ptr = make_unique<int>(10);
    auto arr = make_unique<int[]>(10);
    
    return 0;
}
```

## 2. C++17特性

### 结构化绑定

```cpp
#include <iostream>
#include <tuple>
#include <map>
using namespace std;

int main() {
    // 元组结构化绑定
    tuple<int, string, double> t{1, "Hello", 3.14};
    auto [id, name, value] = t;
    cout << id << " " << name << " " << value << endl;
    
    // pair结构化绑定
    pair<string, int> p{"Alice", 95};
    auto [name2, score] = p;
    cout << name2 << ": " << score << endl;
    
    // map遍历
    map<string, int> scores{{"Alice", 95}, {"Bob", 87}};
    for (const auto& [name, score] : scores) {
        cout << name << ": " << score << endl;
    }
    
    // 数组结构化绑定
    int arr[3] = {1, 2, 3};
    auto [a, b, c] = arr;
    cout << a << " " << b << " " << c << endl;
    
    return 0;
}
```

### if constexpr

```cpp
#include <iostream>
#include <type_traits>
using namespace std;

template<typename T>
void print_value(T value) {
    if constexpr (is_integral_v<T>) {
        cout << "整数: " << value << endl;
    } else if constexpr (is_floating_point_v<T>) {
        cout << "浮点数: " << value << endl;
    } else {
        cout << "其他: " << value << endl;
    }
}

int main() {
    print_value(10);      // 整数
    print_value(3.14);    // 浮点数
    print_value("Hello"); // 其他
    
    return 0;
}
```

### 折叠表达式

```cpp
#include <iostream>
using namespace std;

// 折叠表达式
template<typename... Args>
auto sum(Args... args) {
    return (args + ...);  // 右折叠
}

template<typename... Args>
void print_all(Args... args) {
    ((cout << args << " "), ...);  // 左折叠
    cout << endl;
}

int main() {
    cout << sum(1, 2, 3, 4, 5) << endl;  // 15
    print_all(1, 2, 3, "Hello", 3.14);
    
    return 0;
}
```

### optional（C++17）

```cpp
#include <iostream>
#include <optional>
#include <string>
using namespace std;

optional<int> divide(int a, int b) {
    if (b != 0) {
        return a / b;
    }
    return nullopt;  // 无值
}

int main() {
    auto result = divide(10, 2);
    if (result.has_value()) {
        cout << "结果: " << result.value() << endl;
    }
    
    auto result2 = divide(10, 0);
    if (!result2.has_value()) {
        cout << "除零错误" << endl;
    }
    
    // 使用value_or提供默认值
    int value = result.value_or(0);
    int value2 = result2.value_or(-1);
    
    cout << value << " " << value2 << endl;
    
    return 0;
}
```

### variant（C++17）

```cpp
#include <iostream>
#include <variant>
#include <string>
using namespace std;

int main() {
    variant<int, string, double> v;
    
    v = 10;
    cout << "值: " << get<int>(v) << endl;
    
    v = "Hello";
    cout << "值: " << get<string>(v) << endl;
    
    v = 3.14;
    cout << "值: " << get<double>(v) << endl;
    
    // 访问variant
    visit([](auto& value) {
        cout << "访问: " << value << endl;
    }, v);
    
    return 0;
}
```

### filesystem（C++17）

```cpp
#include <iostream>
#include <filesystem>
namespace fs = std::filesystem;

int main() {
    // 检查文件是否存在
    if (fs::exists("file.txt")) {
        cout << "文件存在" << endl;
    }
    
    // 文件大小
    if (fs::exists("file.txt")) {
        auto size = fs::file_size("file.txt");
        cout << "文件大小: " << size << " 字节" << endl;
    }
    
    // 遍历目录
    for (const auto& entry : fs::directory_iterator(".")) {
        cout << entry.path() << endl;
    }
    
    // 创建目录
    fs::create_directory("new_dir");
    
    // 复制文件
    fs::copy("source.txt", "dest.txt");
    
    return 0;
}
```

## 3. C++20特性

### Concepts（C++20）

```cpp
#include <concepts>
#include <iostream>
using namespace std;

// 定义概念
template<typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> same_as<T>;
};

// 使用概念
template<Addable T>
T add(T a, T b) {
    return a + b;
}

// 概念组合
template<typename T>
concept Number = integral<T> || floating_point<T>;

template<Number T>
void print_number(T n) {
    cout << n << endl;
}

int main() {
    cout << add(10, 20) << endl;
    print_number(100);
    print_number(3.14);
    
    return 0;
}
```

### Ranges（C++20）

```cpp
#include <iostream>
#include <ranges>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> vec{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 使用ranges
    auto even = vec | views::filter([](int x) { return x % 2 == 0; })
                    | views::transform([](int x) { return x * 2; });
    
    for (int x : even) {
        cout << x << " ";
    }
    cout << endl;
    
    return 0;
}
```

### 协程（C++20）

```cpp
// C++20协程示例（简化版）
#include <coroutine>
#include <iostream>

template<typename T>
struct Generator {
    struct promise_type {
        T current_value;
        
        auto get_return_object() {
            return Generator{coroutine_handle<promise_type>::from_promise(*this)};
        }
        
        auto initial_suspend() { return suspend_always{}; }
        auto final_suspend() noexcept { return suspend_always{}; }
        void unhandled_exception() { std::terminate(); }
        
        auto yield_value(T value) {
            current_value = value;
            return suspend_always{};
        }
    };
    
    coroutine_handle<promise_type> coro;
    
    Generator(coroutine_handle<promise_type> h) : coro(h) {}
    ~Generator() { if (coro) coro.destroy(); }
    
    bool next() {
        coro.resume();
        return !coro.done();
    }
    
    T value() { return coro.promise().current_value; }
};

Generator<int> range(int start, int end) {
    for (int i = start; i < end; ++i) {
        co_yield i;
    }
}
```

## 4. 综合示例

```cpp
#include <iostream>
#include <vector>
#include <optional>
#include <ranges>
#include <algorithm>
using namespace std;

// 使用C++17和C++20特性
void modern_cpp_example() {
    vector<int> numbers{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // C++17: structured binding和optional
    optional<int> find_number(const vector<int>& vec, int target) {
        auto it = find(vec.begin(), vec.end(), target);
        if (it != vec.end()) {
            return *it;
        }
        return nullopt;
    }
    
    auto result = find_number(numbers, 5);
    if (result.has_value()) {
        cout << "找到: " << result.value() << endl;
    }
    
    // C++20: ranges（如果编译器支持）
    // auto filtered = numbers | views::filter([](int x) { return x % 2 == 0; });
}
```

## 练习

1. 使用结构化绑定简化代码
2. 使用optional处理可能失败的操作
3. 使用filesystem库操作文件和目录
4. 使用if constexpr实现编译期分支
5. 了解C++20的concepts和ranges（如果编译器支持）

