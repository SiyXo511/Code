# C++运算符重载

本教程将学习C++中的运算符重载，包括常用运算符的重载、友元运算符等。

## 1. 运算符重载基础

```cpp
#include <iostream>
using namespace std;

class Complex {
private:
    double real, imag;
    
public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}
    
    // 重载+运算符
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }
    
    // 重载-运算符
    Complex operator-(const Complex& other) const {
        return Complex(real - other.real, imag - other.imag);
    }
    
    // 重载*运算符
    Complex operator*(const Complex& other) const {
        return Complex(real * other.real - imag * other.imag,
                      real * other.imag + imag * other.real);
    }
    
    // 重载==运算符
    bool operator==(const Complex& other) const {
        return (real == other.real) && (imag == other.imag);
    }
    
    // 显示复数
    void display() const {
        cout << real;
        if (imag >= 0) cout << "+";
        cout << imag << "i" << endl;
    }
};

int main() {
    Complex c1(3, 4);
    Complex c2(1, 2);
    
    Complex c3 = c1 + c2;  // 使用重载的+运算符
    c3.display();
    
    Complex c4 = c1 - c2;
    c4.display();
    
    Complex c5 = c1 * c2;
    c5.display();
    
    if (c1 == c2) {
        cout << "相等" << endl;
    } else {
        cout << "不相等" << endl;
    }
    
    return 0;
}
```

## 2. 赋值运算符重载

```cpp
#include <iostream>
#include <cstring>
using namespace std;

class String {
private:
    char* data;
    int length;
    
public:
    // 构造函数
    String(const char* str = "") {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
    }
    
    // 拷贝构造函数
    String(const String& other) {
        length = other.length;
        data = new char[length + 1];
        strcpy(data, other.data);
    }
    
    // 赋值运算符重载（深拷贝）
    String& operator=(const String& other) {
        if (this != &other) {  // 避免自我赋值
            delete[] data;
            length = other.length;
            data = new char[length + 1];
            strcpy(data, other.data);
        }
        return *this;  // 返回自身引用，支持链式赋值
    }
    
    // 析构函数
    ~String() {
        delete[] data;
    }
    
    // 重载[]运算符
    char& operator[](int index) {
        return data[index];
    }
    
    const char& operator[](int index) const {
        return data[index];
    }
    
    // 显示字符串
    void display() const {
        cout << data << endl;
    }
};

int main() {
    String str1("Hello");
    String str2("World");
    
    str1.display();
    str2.display();
    
    str2 = str1;  // 使用重载的赋值运算符
    str2.display();
    
    str1[0] = 'h';  // 使用重载的[]运算符
    str1.display();
    
    return 0;
}
```

## 3. 输入输出运算符重载

```cpp
#include <iostream>
using namespace std;

class Complex {
private:
    double real, imag;
    
public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}
    
    // 友元函数：重载<<运算符
    friend ostream& operator<<(ostream& os, const Complex& c);
    
    // 友元函数：重载>>运算符
    friend istream& operator>>(istream& is, Complex& c);
    
    // 重载+运算符
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }
};

// 输出运算符重载
ostream& operator<<(ostream& os, const Complex& c) {
    os << c.real;
    if (c.imag >= 0) os << "+";
    os << c.imag << "i";
    return os;
}

// 输入运算符重载
istream& operator>>(istream& is, Complex& c) {
    cout << "输入实部: ";
    is >> c.real;
    cout << "输入虚部: ";
    is >> c.imag;
    return is;
}

int main() {
    Complex c1(3, 4);
    cout << c1 << endl;  // 使用重载的<<运算符
    
    Complex c2;
    cin >> c2;  // 使用重载的>>运算符
    cout << c2 << endl;
    
    Complex c3 = c1 + c2;
    cout << c3 << endl;
    
    return 0;
}
```

## 4. 自增自减运算符重载

```cpp
#include <iostream>
using namespace std;

class Counter {
private:
    int count;
    
public:
    Counter(int c = 0) : count(c) {}
    
    // 前置++运算符
    Counter& operator++() {
        ++count;
        return *this;  // 返回自身引用
    }
    
    // 后置++运算符（需要int参数区分）
    Counter operator++(int) {
        Counter temp = *this;
        count++;
        return temp;  // 返回旧值
    }
    
    // 前置--运算符
    Counter& operator--() {
        --count;
        return *this;
    }
    
    // 后置--运算符
    Counter operator--(int) {
        Counter temp = *this;
        count--;
        return temp;
    }
    
    void display() const {
        cout << "计数: " << count << endl;
    }
};

int main() {
    Counter c(5);
    c.display();
    
    ++c;  // 前置++
    c.display();
    
    c++;  // 后置++
    c.display();
    
    Counter d = ++c;  // d = 8
    Counter e = c++;  // e = 8, c = 9
    
    cout << "d: ";
    d.display();
    cout << "e: ";
    e.display();
    cout << "c: ";
    c.display();
    
    return 0;
}
```

## 5. 函数调用运算符重载

```cpp
#include <iostream>
using namespace std;

class Multiplier {
private:
    int factor;
    
public:
    Multiplier(int f) : factor(f) {}
    
    // 重载()运算符（函数调用运算符）
    int operator()(int x) const {
        return x * factor;
    }
    
    double operator()(double x) const {
        return x * factor;
    }
};

int main() {
    Multiplier mult(3);
    
    cout << mult(10) << endl;    // 30
    cout << mult(3.14) << endl;  // 9.42
    
    // 可以作为函数对象使用
    Multiplier mult2(5);
    cout << mult2(7) << endl;    // 35
    
    return 0;
}
```

## 6. 比较运算符重载

```cpp
#include <iostream>
#include <string>
using namespace std;

class Person {
private:
    string name;
    int age;
    
public:
    Person(string n, int a) : name(n), age(a) {}
    
    // 重载<运算符
    bool operator<(const Person& other) const {
        return age < other.age;
    }
    
    // 重载>运算符
    bool operator>(const Person& other) const {
        return age > other.age;
    }
    
    // 重载<=运算符
    bool operator<=(const Person& other) const {
        return age <= other.age;
    }
    
    // 重载>=运算符
    bool operator>=(const Person& other) const {
        return age >= other.age;
    }
    
    // 重载==运算符
    bool operator==(const Person& other) const {
        return (name == other.name) && (age == other.age);
    }
    
    // 重载!=运算符
    bool operator!=(const Person& other) const {
        return !(*this == other);
    }
    
    void display() const {
        cout << name << " (" << age << ")" << endl;
    }
};

int main() {
    Person p1("张三", 25);
    Person p2("李四", 30);
    
    if (p1 < p2) {
        cout << "p1比p2年轻" << endl;
    }
    
    if (p1 != p2) {
        cout << "p1和p2不同" << endl;
    }
    
    return 0;
}
```

## 7. 类型转换运算符

```cpp
#include <iostream>
#include <string>
using namespace std;

class Rational {
private:
    int numerator, denominator;
    
public:
    Rational(int num = 0, int den = 1) 
        : numerator(num), denominator(den) {}
    
    // 转换为double
    operator double() const {
        return static_cast<double>(numerator) / denominator;
    }
    
    // 转换为字符串
    operator string() const {
        return to_string(numerator) + "/" + to_string(denominator);
    }
    
    // 转换为bool（非零为true）
    explicit operator bool() const {  // C++11: explicit防止隐式转换
        return numerator != 0;
    }
    
    void display() const {
        cout << numerator << "/" << denominator << endl;
    }
};

int main() {
    Rational r(3, 4);
    
    double d = r;  // 隐式类型转换
    cout << d << endl;
    
    string s = r;  // 隐式类型转换
    cout << s << endl;
    
    // if (r) {  // 需要显式转换，因为有explicit
    if (static_cast<bool>(r)) {
        cout << "r不为零" << endl;
    }
    
    return 0;
}
```

## 8. 综合示例

```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;
    
public:
    Vector(double x = 0, double y = 0, double z = 0) 
        : x(x), y(y), z(z) {}
    
    // 重载+运算符
    Vector operator+(const Vector& other) const {
        return Vector(x + other.x, y + other.y, z + other.z);
    }
    
    // 重载-运算符
    Vector operator-(const Vector& other) const {
        return Vector(x - other.x, y - other.y, z - other.z);
    }
    
    // 重载*运算符（点积）
    double operator*(const Vector& other) const {
        return x * other.x + y * other.y + z * other.z;
    }
    
    // 重载*运算符（标量乘法）
    Vector operator*(double scalar) const {
        return Vector(x * scalar, y * scalar, z * scalar);
    }
    
    // 友元：标量*向量
    friend Vector operator*(double scalar, const Vector& v);
    
    // 重载+=运算符
    Vector& operator+=(const Vector& other) {
        x += other.x;
        y += other.y;
        z += other.z;
        return *this;
    }
    
    // 重载输出运算符
    friend ostream& operator<<(ostream& os, const Vector& v);
};

Vector operator*(double scalar, const Vector& v) {
    return v * scalar;
}

ostream& operator<<(ostream& os, const Vector& v) {
    os << "(" << v.x << ", " << v.y << ", " << v.z << ")";
    return os;
}

int main() {
    Vector v1(1, 2, 3);
    Vector v2(4, 5, 6);
    
    Vector v3 = v1 + v2;
    cout << "v1 + v2 = " << v3 << endl;
    
    double dot = v1 * v2;
    cout << "v1 · v2 = " << dot << endl;
    
    Vector v4 = v1 * 2;
    cout << "v1 * 2 = " << v4 << endl;
    
    Vector v5 = 3 * v1;
    cout << "3 * v1 = " << v5 << endl;
    
    v1 += v2;
    cout << "v1 += v2: " << v1 << endl;
    
    return 0;
}
```

## 练习

1. 实现一个Time类，重载+、-、==等运算符
2. 创建一个Matrix类，重载矩阵加法、乘法等运算符
3. 实现一个智能指针类，重载*和->运算符
4. 创建一个分数类Fraction，重载所有算术运算符

