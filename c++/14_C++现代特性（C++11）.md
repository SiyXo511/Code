# C++现代特性（C++11）

本教程将学习C++11引入的现代特性，包括auto、nullptr、右值引用、移动语义、Lambda表达式等。

## 1. auto关键字

```cpp
#include <iostream>
#include <vector>
#include <map>
using namespace std;

int main() {
    // auto自动推导类型
    auto x = 10;           // int
    auto y = 3.14;         // double
    auto z = "Hello";      // const char*
    
    vector<int> vec{1, 2, 3, 4, 5};
    auto it = vec.begin();  // vector<int>::iterator
    
    // 简化代码
    map<string, int> scores;
    scores["Alice"] = 95;
    scores["Bob"] = 87;
    
    // 使用auto简化迭代器
    for (auto it = scores.begin(); it != scores.end(); ++it) {
        cout << it->first << ": " << it->second << endl;
    }
    
    // auto用于函数返回类型（C++14）
    auto func = []() { return 42; };
    auto result = func();
    
    return 0;
}
```

## 2. nullptr

```cpp
#include <iostream>
using namespace std;

void func(int* ptr) {
    if (ptr == nullptr) {  // C++11推荐使用nullptr
        cout << "指针为空" << endl;
    } else {
        cout << "指针不为空" << endl;
    }
}

int main() {
    int* ptr1 = nullptr;   // C++11推荐
    // int* ptr2 = NULL;   // C风格，不推荐
    
    func(ptr1);
    func(nullptr);
    
    // nullptr可以转换为指针类型，但不能转换为整数
    // int x = nullptr;  // 错误
    
    return 0;
}
```

## 3. 范围for循环

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <string>
using namespace std;

int main() {
    vector<int> vec{1, 2, 3, 4, 5};
    
    // 范围for循环
    for (int x : vec) {
        cout << x << " ";
    }
    cout << endl;
    
    // 使用auto
    for (auto x : vec) {
        cout << x << " ";
    }
    cout << endl;
    
    // 使用引用（可以修改）
    for (auto& x : vec) {
        x *= 2;
    }
    
    // 使用const引用（不能修改）
    for (const auto& x : vec) {
        cout << x << " ";
    }
    cout << endl;
    
    // 遍历map
    map<string, int> scores{{"Alice", 95}, {"Bob", 87}};
    for (const auto& pair : scores) {
        cout << pair.first << ": " << pair.second << endl;
    }
    
    return 0;
}
```

## 4. 初始化列表

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <initializer_list>
using namespace std;

// 类中使用初始化列表
class MyClass {
private:
    vector<int> data;
    
public:
    // 初始化列表构造函数
    MyClass(initializer_list<int> init) : data(init) {}
    
    void display() {
        for (int x : data) {
            cout << x << " ";
        }
        cout << endl;
    }
};

int main() {
    // 统一初始化语法
    int x{10};
    int arr[]{1, 2, 3, 4, 5};
    vector<int> vec{1, 2, 3, 4, 5};
    map<string, int> m{{"Alice", 95}, {"Bob", 87}};
    
    // 类初始化
    MyClass obj{10, 20, 30, 40};
    obj.display();
    
    // 初始化列表防止窄化转换
    // int y{3.14};  // 错误：窄化转换
    
    return 0;
}
```

## 5. 右值引用和移动语义

### 左值和右值

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    // 左值：有名称，可以取地址
    int x = 10;      // x是左值
    int& ref = x;    // ref是左值引用
    
    // 右值：临时值，不能取地址
    int y = x + 5;   // x+5是右值
    // int& ref2 = x + 5;  // 错误：不能绑定右值到左值引用
    
    // 右值引用（C++11）
    int&& rref = 10;        // 右值引用可以绑定右值
    int&& rref2 = x + 5;
    
    // 移动语义
    string str1 = "Hello";
    string str2 = move(str1);  // move: 将左值转为右值
    
    cout << "str1: " << str1 << endl;  // 可能为空
    cout << "str2: " << str2 << endl;  // "Hello"
    
    return 0;
}
```

### 移动构造函数和移动赋值

```cpp
#include <iostream>
#include <cstring>
using namespace std;

class String {
private:
    char* data;
    size_t size;
    
public:
    // 构造函数
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
        cout << "构造函数" << endl;
    }
    
    // 拷贝构造函数
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        cout << "拷贝构造函数" << endl;
    }
    
    // 移动构造函数（C++11）
    String(String&& other) noexcept {
        data = other.data;
        size = other.size;
        other.data = nullptr;
        other.size = 0;
        cout << "移动构造函数" << endl;
    }
    
    // 拷贝赋值
    String& operator=(const String& other) {
        if (this != &other) {
            delete[] data;
            size = other.size;
            data = new char[size + 1];
            strcpy(data, other.data);
        }
        cout << "拷贝赋值" << endl;
        return *this;
    }
    
    // 移动赋值（C++11）
    String& operator=(String&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            size = other.size;
            other.data = nullptr;
            other.size = 0;
        }
        cout << "移动赋值" << endl;
        return *this;
    }
    
    ~String() {
        delete[] data;
    }
    
    void display() const {
        if (data) {
            cout << data << endl;
        } else {
            cout << "(空)" << endl;
        }
    }
};

String createString() {
    return String("临时字符串");
}

int main() {
    String s1("Hello");
    String s2 = s1;              // 拷贝构造
    String s3 = move(s1);        // 移动构造
    String s4 = createString();  // 移动构造（返回值优化）
    
    s2 = s3;                     // 拷贝赋值
    s2 = move(s3);               // 移动赋值
    
    return 0;
}
```

## 6. Lambda表达式

### 基本Lambda

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    // 基本Lambda
    auto add = [](int a, int b) {
        return a + b;
    };
    cout << add(10, 20) << endl;
    
    // Lambda作为参数
    vector<int> vec{5, 2, 8, 1, 9, 3};
    
    // 排序
    sort(vec.begin(), vec.end(), [](int a, int b) {
        return a > b;  // 降序
    });
    
    for (int x : vec) {
        cout << x << " ";
    }
    cout << endl;
    
    // 查找
    auto it = find_if(vec.begin(), vec.end(),
                     [](int x) { return x > 5; });
    if (it != vec.end()) {
        cout << "找到: " << *it << endl;
    }
    
    return 0;
}
```

### Lambda捕获

```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 10;
    int y = 20;
    
    // 按值捕获
    auto lambda1 = [x, y]() {
        // x和y按值捕获，不能修改
        return x + y;
    };
    
    // 按引用捕获
    auto lambda2 = [&x, &y]() {
        x++;  // 可以修改
        y++;
        return x + y;
    };
    
    // 捕获所有（按值）
    auto lambda3 = [=]() {
        return x + y;
    };
    
    // 捕获所有（按引用）
    auto lambda4 = [&]() {
        x++;
        y++;
        return x + y;
    };
    
    // 混合捕获
    auto lambda5 = [=, &x]() {
        // x按引用，其他按值
        x++;
        return x + y;
    };
    
    // 可变Lambda（允许修改按值捕获的变量）
    auto lambda6 = [x]() mutable {
        x++;  // 修改的是副本，不影响外部x
        return x;
    };
    
    cout << lambda1() << endl;
    cout << lambda2() << endl;
    
    return 0;
}
```

## 7. 智能指针

### unique_ptr

```cpp
#include <iostream>
#include <memory>
using namespace std;

class Resource {
public:
    Resource(int id) : id(id) {
        cout << "Resource " << id << " 创建" << endl;
    }
    
    ~Resource() {
        cout << "Resource " << id << " 销毁" << endl;
    }
    
    void use() {
        cout << "使用Resource " << id << endl;
    }
    
private:
    int id;
};

int main() {
    // unique_ptr：独占所有权
    unique_ptr<Resource> ptr1(new Resource(1));
    ptr1->use();
    
    // 使用make_unique（C++14）
    auto ptr2 = make_unique<Resource>(2);
    ptr2->use();
    
    // 不能复制，只能移动
    // unique_ptr<Resource> ptr3 = ptr2;  // 错误
    unique_ptr<Resource> ptr3 = move(ptr2);  // 可以移动
    
    if (!ptr2) {
        cout << "ptr2已移动" << endl;
    }
    
    // 数组
    auto arr = make_unique<int[]>(10);
    arr[0] = 100;
    
    // 自动释放
    return 0;
}
```

### shared_ptr

```cpp
#include <iostream>
#include <memory>
using namespace std;

class Resource {
public:
    Resource(int id) : id(id) {
        cout << "Resource " << id << " 创建" << endl;
    }
    
    ~Resource() {
        cout << "Resource " << id << " 销毁" << endl;
    }
    
private:
    int id;
};

int main() {
    // shared_ptr：共享所有权
    shared_ptr<Resource> ptr1 = make_shared<Resource>(1);
    cout << "引用计数: " << ptr1.use_count() << endl;
    
    {
        shared_ptr<Resource> ptr2 = ptr1;  // 可以复制
        cout << "引用计数: " << ptr1.use_count() << endl;
        
        shared_ptr<Resource> ptr3 = ptr1;
        cout << "引用计数: " << ptr1.use_count() << endl;
    }  // ptr2和ptr3离开作用域
    
    cout << "引用计数: " << ptr1.use_count() << endl;
    
    // 当引用计数为0时，自动释放
    
    return 0;
}
```

### weak_ptr

```cpp
#include <iostream>
#include <memory>
using namespace std;

int main() {
    shared_ptr<int> shared = make_shared<int>(100);
    weak_ptr<int> weak = shared;
    
    cout << "shared引用计数: " << shared.use_count() << endl;
    
    // 检查weak_ptr是否有效
    if (auto locked = weak.lock()) {
        cout << "weak_ptr有效，值: " << *locked << endl;
    }
    
    shared.reset();
    
    if (weak.expired()) {
        cout << "weak_ptr已过期" << endl;
    }
    
    return 0;
}
```

## 8. 综合示例

```cpp
#include <iostream>
#include <vector>
#include <memory>
#include <algorithm>
using namespace std;

int main() {
    // 使用现代C++特性
    auto numbers = make_shared<vector<int>>(vector<int>{5, 2, 8, 1, 9, 3});
    
    // 使用Lambda和范围for
    for_each(numbers->begin(), numbers->end(),
            [](int& x) { x *= 2; });
    
    // 范围for循环
    for (const auto& x : *numbers) {
        cout << x << " ";
    }
    cout << endl;
    
    return 0;
}
```

## 练习

1. 使用auto简化代码中的类型声明
2. 使用移动语义优化类的拷贝性能
3. 使用Lambda表达式实现各种算法
4. 使用智能指针管理资源，避免内存泄漏
5. 比较C++98和C++11的代码风格差异

