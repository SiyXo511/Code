# C++多线程编程

本教程将学习C++11引入的多线程编程，包括线程创建、互斥量、条件变量、原子操作等。

## 1. 线程创建

### 基本线程

```cpp
#include <iostream>
#include <thread>
#include <chrono>
using namespace std;

void thread_function(int id) {
    for (int i = 0; i < 5; i++) {
        cout << "线程 " << id << ": " << i << endl;
        this_thread::sleep_for(chrono::milliseconds(100));
    }
}

int main() {
    // 创建线程
    thread t1(thread_function, 1);
    thread t2(thread_function, 2);
    
    // 等待线程完成
    t1.join();
    t2.join();
    
    cout << "所有线程完成" << endl;
    
    return 0;
}
```

### Lambda表达式创建线程

```cpp
#include <iostream>
#include <thread>
using namespace std;

int main() {
    // 使用Lambda创建线程
    thread t1([]() {
        for (int i = 0; i < 5; i++) {
            cout << "Lambda线程: " << i << endl;
        }
    });
    
    t1.join();
    
    return 0;
}
```

## 2. 互斥量和锁

### mutex

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
using namespace std;

mutex mtx;
int counter = 0;

void increment() {
    for (int i = 0; i < 1000; i++) {
        mtx.lock();
        counter++;
        mtx.unlock();
    }
}

int main() {
    vector<thread> threads;
    
    for (int i = 0; i < 5; i++) {
        threads.push_back(thread(increment));
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    cout << "最终计数: " << counter << endl;
    
    return 0;
}
```

### lock_guard（RAII）

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
using namespace std;

mutex mtx;
int counter = 0;

void increment_safe() {
    for (int i = 0; i < 1000; i++) {
        lock_guard<mutex> lock(mtx);  // 自动加锁和解锁
        counter++;
    }  // lock自动解锁
}

int main() {
    vector<thread> threads;
    
    for (int i = 0; i < 5; i++) {
        threads.push_back(thread(increment_safe));
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    cout << "最终计数: " << counter << endl;
    
    return 0;
}
```

### unique_lock

```cpp
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

mutex mtx;

void function_with_unique_lock() {
    unique_lock<mutex> lock(mtx);
    
    // 可以手动解锁
    lock.unlock();
    
    // 可以重新加锁
    lock.lock();
    
    // 自动解锁
}

int main() {
    function_with_unique_lock();
    return 0;
}
```

## 3. 条件变量

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
using namespace std;

mutex mtx;
condition_variable cv;
queue<int> q;
bool finished = false;

void producer() {
    for (int i = 0; i < 10; i++) {
        {
            lock_guard<mutex> lock(mtx);
            q.push(i);
            cout << "生产: " << i << endl;
        }
        cv.notify_one();
        this_thread::sleep_for(chrono::milliseconds(100));
    }
    
    {
        lock_guard<mutex> lock(mtx);
        finished = true;
    }
    cv.notify_all();
}

void consumer(int id) {
    while (true) {
        unique_lock<mutex> lock(mtx);
        cv.wait(lock, [] { return !q.empty() || finished; });
        
        if (finished && q.empty()) {
            break;
        }
        
        if (!q.empty()) {
            int item = q.front();
            q.pop();
            cout << "消费者 " << id << " 消费: " << item << endl;
        }
    }
}

int main() {
    thread prod(producer);
    thread cons1(consumer, 1);
    thread cons2(consumer, 2);
    
    prod.join();
    cons1.join();
    cons2.join();
    
    return 0;
}
```

## 4. 原子操作

```cpp
#include <iostream>
#include <thread>
#include <atomic>
#include <vector>
using namespace std;

atomic<int> counter{0};  // 原子变量

void increment_atomic() {
    for (int i = 0; i < 1000; i++) {
        counter++;  // 原子操作，不需要加锁
    }
}

int main() {
    vector<thread> threads;
    
    for (int i = 0; i < 5; i++) {
        threads.push_back(thread(increment_atomic));
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    cout << "最终计数: " << counter << endl;
    
    return 0;
}
```

### 原子操作函数

```cpp
#include <iostream>
#include <atomic>
using namespace std;

int main() {
    atomic<int> value{10};
    
    // 原子操作
    int old = value.fetch_add(5);  // value += 5, 返回旧值
    cout << "旧值: " << old << ", 新值: " << value << endl;
    
    value.fetch_sub(3);  // value -= 3
    cout << "减3后: " << value << endl;
    
    // 比较交换
    int expected = 12;
    bool success = value.compare_exchange_strong(expected, 100);
    cout << "交换成功: " << success << ", value: " << value << endl;
    
    return 0;
}
```

## 5. async和future

```cpp
#include <iostream>
#include <future>
#include <thread>
using namespace std;

int calculate(int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += i;
    }
    return sum;
}

int main() {
    // async: 异步执行
    future<int> fut = async(calculate, 1000000);
    
    // 做其他事情
    cout << "等待结果..." << endl;
    
    // 获取结果（会阻塞直到完成）
    int result = fut.get();
    cout << "结果: " << result << endl;
    
    // 使用packaged_task
    packaged_task<int(int)> task(calculate);
    future<int> fut2 = task.get_future();
    
    thread t(move(task), 1000000);
    
    int result2 = fut2.get();
    cout << "结果2: " << result2 << endl;
    
    t.join();
    
    return 0;
}
```

### promise和future

```cpp
#include <iostream>
#include <future>
#include <thread>
using namespace std;

void producer(promise<int> prom) {
    this_thread::sleep_for(chrono::seconds(2));
    prom.set_value(100);  // 设置值
}

int main() {
    promise<int> prom;
    future<int> fut = prom.get_future();
    
    thread t(producer, move(prom));
    
    // 等待值
    int value = fut.get();
    cout << "收到值: " << value << endl;
    
    t.join();
    
    return 0;
}
```

## 6. 综合示例

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <atomic>
#include <vector>
#include <future>
using namespace std;

// 线程安全计数器
class ThreadSafeCounter {
private:
    atomic<int> count{0};
    
public:
    void increment() {
        count++;
    }
    
    int get() const {
        return count;
    }
};

int main() {
    ThreadSafeCounter counter;
    vector<thread> threads;
    
    // 多线程递增
    for (int i = 0; i < 10; i++) {
        threads.push_back(thread([&counter]() {
            for (int j = 0; j < 1000; j++) {
                counter.increment();
            }
        }));
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    cout << "最终计数: " << counter.get() << endl;
    
    return 0;
}
```

## 练习

1. 实现一个线程安全的消息队列
2. 使用多线程计算数组的和
3. 实现一个线程池
4. 使用async实现并行计算
5. 实现生产者-消费者模式的完整版本

