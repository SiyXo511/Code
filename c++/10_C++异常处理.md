# C++异常处理

本教程将学习C++中的异常处理，包括try-catch块、抛出异常、标准异常类等。

## 1. 异常处理基础

### try-catch块

```cpp
#include <iostream>
#include <stdexcept>
using namespace std;

int divide(int a, int b) {
    if (b == 0) {
        throw runtime_error("除数不能为零！");
    }
    return a / b;
}

int main() {
    try {
        int result = divide(10, 0);
        cout << "结果: " << result << endl;
    }
    catch (const runtime_error& e) {
        cout << "捕获异常: " << e.what() << endl;
    }
    
    try {
        int result = divide(10, 2);
        cout << "结果: " << result << endl;
    }
    catch (const runtime_error& e) {
        cout << "捕获异常: " << e.what() << endl;
    }
    
    return 0;
}
```

### 多个catch块

```cpp
#include <iostream>
#include <stdexcept>
#include <string>
using namespace std;

void test(int x) {
    if (x < 0) {
        throw invalid_argument("参数不能为负数");
    }
    if (x > 100) {
        throw out_of_range("参数超出范围");
    }
    if (x == 50) {
        throw string("特殊异常");
    }
}

int main() {
    try {
        test(-10);
    }
    catch (const invalid_argument& e) {
        cout << "无效参数: " << e.what() << endl;
    }
    catch (const out_of_range& e) {
        cout << "超出范围: " << e.what() << endl;
    }
    catch (const string& e) {
        cout << "字符串异常: " << e << endl;
    }
    catch (...) {  // 捕获所有异常
        cout << "未知异常" << endl;
    }
    
    return 0;
}
```

## 2. 抛出异常

### 抛出标准异常

```cpp
#include <iostream>
#include <stdexcept>
#include <vector>
using namespace std;

int getElement(const vector<int>& vec, int index) {
    if (index < 0 || index >= vec.size()) {
        throw out_of_range("索引超出范围");
    }
    return vec[index];
}

double sqrt_safe(double x) {
    if (x < 0) {
        throw domain_error("不能对负数开平方");
    }
    // 简化的平方根计算
    return x;  // 实际应该使用sqrt函数
}

int main() {
    vector<int> vec = {1, 2, 3, 4, 5};
    
    try {
        cout << getElement(vec, 2) << endl;
        cout << getElement(vec, 10) << endl;  // 抛出异常
    }
    catch (const out_of_range& e) {
        cout << "错误: " << e.what() << endl;
    }
    
    try {
        cout << sqrt_safe(4) << endl;
        cout << sqrt_safe(-4) << endl;  // 抛出异常
    }
    catch (const domain_error& e) {
        cout << "错误: " << e.what() << endl;
    }
    
    return 0;
}
```

### 抛出自定义异常

```cpp
#include <iostream>
#include <string>
using namespace std;

// 自定义异常类
class MyException : public exception {
private:
    string message;
    
public:
    MyException(const string& msg) : message(msg) {}
    
    const char* what() const noexcept override {
        return message.c_str();
    }
};

class DivisionByZeroException : public MyException {
public:
    DivisionByZeroException() : MyException("除数不能为零") {}
};

class NegativeNumberException : public MyException {
public:
    NegativeNumberException() : MyException("数字不能为负数") {}
};

int safe_divide(int a, int b) {
    if (b == 0) {
        throw DivisionByZeroException();
    }
    if (a < 0 || b < 0) {
        throw NegativeNumberException();
    }
    return a / b;
}

int main() {
    try {
        int result = safe_divide(10, 0);
        cout << "结果: " << result << endl;
    }
    catch (const MyException& e) {
        cout << "捕获异常: " << e.what() << endl;
    }
    
    try {
        int result = safe_divide(-10, 5);
        cout << "结果: " << result << endl;
    }
    catch (const MyException& e) {
        cout << "捕获异常: " << e.what() << endl;
    }
    
    return 0;
}
```

## 3. 标准异常类

```cpp
#include <iostream>
#include <stdexcept>
#include <new>
#include <typeinfo>
using namespace std;

int main() {
    // 1. runtime_error系列
    try {
        throw runtime_error("运行时错误");
    }
    catch (const runtime_error& e) {
        cout << e.what() << endl;
    }
    
    // 2. logic_error系列
    try {
        throw invalid_argument("无效参数");
    }
    catch (const invalid_argument& e) {
        cout << e.what() << endl;
    }
    
    try {
        throw out_of_range("超出范围");
    }
    catch (const out_of_range& e) {
        cout << e.what() << endl;
    }
    
    // 3. bad_alloc（内存分配失败）
    try {
        int* arr = new int[1000000000000LL];
        delete[] arr;
    }
    catch (const bad_alloc& e) {
        cout << "内存分配失败: " << e.what() << endl;
    }
    
    // 4. bad_cast（类型转换失败）
    try {
        int x = 10;
        double& d = dynamic_cast<double&>(reinterpret_cast<double&>(x));
    }
    catch (const bad_cast& e) {
        cout << "类型转换失败: " << e.what() << endl;
    }
    
    return 0;
}
```

## 4. 异常规格说明（已废弃）

```cpp
// C++98/03 异常规格说明（已废弃，不推荐使用）
// void func() throw(int, string);  // 只能抛出int或string
// void func() throw();              // 不能抛出任何异常

// C++11: noexcept说明符（推荐使用）
void func_noexcept() noexcept {
    // 不抛出异常
}

void func_maybe() noexcept(false) {
    // 可能抛出异常
}

// noexcept操作符
void test() {
    cout << noexcept(func_noexcept()) << endl;   // true
    cout << noexcept(func_maybe()) << endl;      // false
}
```

## 5. 异常安全

### 异常安全级别

```cpp
#include <iostream>
#include <stdexcept>
using namespace std;

class Resource {
private:
    int* data;
    int size;
    
public:
    // 基本异常安全：不泄漏资源
    Resource(int s) : size(s) {
        data = new int[size];
        // 如果这里抛出异常，会自动调用析构函数
    }
    
    // 强异常安全：要么成功，要么恢复原状态
    Resource& operator=(const Resource& other) {
        if (this != &other) {
            int* newData = new int[other.size];
            // 先分配新内存，成功后再删除旧内存
            delete[] data;
            data = newData;
            size = other.size;
            for (int i = 0; i < size; i++) {
                data[i] = other.data[i];
            }
        }
        return *this;
    }
    
    ~Resource() {
        delete[] data;
    }
};

// 无异常保证：不抛出异常
int add(int a, int b) noexcept {
    return a + b;
}
```

### RAII和异常安全

```cpp
#include <iostream>
#include <fstream>
#include <memory>
using namespace std;

// 使用RAII确保资源释放
void readFile(const string& filename) {
    ifstream file(filename);
    if (!file.is_open()) {
        throw runtime_error("无法打开文件: " + filename);
    }
    
    // 即使抛出异常，file也会自动关闭
    string line;
    while (getline(file, line)) {
        cout << line << endl;
        // 如果这里抛出异常，file会自动关闭
    }
    // file在这里自动关闭
}

// 使用智能指针确保内存释放
void processData() {
    unique_ptr<int[]> data(new int[1000]);
    // 即使抛出异常，data也会自动释放
    // ... 使用data ...
    // data在这里自动释放
}
```

## 6. 异常传播

```cpp
#include <iostream>
#include <stdexcept>
using namespace std;

void level3() {
    throw runtime_error("level3异常");
}

void level2() {
    try {
        level3();
    }
    catch (const runtime_error& e) {
        cout << "level2捕获异常: " << e.what() << endl;
        throw;  // 重新抛出异常
    }
}

void level1() {
    try {
        level2();
    }
    catch (const runtime_error& e) {
        cout << "level1捕获异常: " << e.what() << endl;
        // 可以修改异常信息后重新抛出
        throw runtime_error("level1重新抛出: " + string(e.what()));
    }
}

int main() {
    try {
        level1();
    }
    catch (const runtime_error& e) {
        cout << "main捕获异常: " << e.what() << endl;
    }
    
    return 0;
}
```

## 7. 综合示例

### 完整的异常处理示例

```cpp
#include <iostream>
#include <stdexcept>
#include <vector>
#include <memory>
using namespace std;

class SafeVector {
private:
    vector<int> data;
    
public:
    void push_back(int value) {
        if (data.size() >= 1000) {
            throw overflow_error("向量已满");
        }
        data.push_back(value);
    }
    
    int at(int index) const {
        if (index < 0 || index >= data.size()) {
            throw out_of_range("索引 " + to_string(index) + " 超出范围");
        }
        return data[index];
    }
    
    int size() const {
        return data.size();
    }
};

int main() {
    SafeVector vec;
    
    try {
        // 正常操作
        for (int i = 0; i < 10; i++) {
            vec.push_back(i);
        }
        
        cout << "元素: ";
        for (int i = 0; i < vec.size(); i++) {
            cout << vec.at(i) << " ";
        }
        cout << endl;
        
        // 访问越界
        cout << vec.at(20) << endl;
    }
    catch (const out_of_range& e) {
        cout << "越界错误: " << e.what() << endl;
    }
    catch (const overflow_error& e) {
        cout << "溢出错误: " << e.what() << endl;
    }
    catch (...) {
        cout << "未知错误" << endl;
    }
    
    return 0;
}
```

## 练习

1. 创建一个银行账户类，处理余额不足等异常
2. 实现一个文件读取类，处理文件不存在、读取失败等异常
3. 创建一个计算器类，处理除零、无效操作等异常
4. 实现一个安全的数组类，处理越界访问等异常
5. 使用异常处理改进你的项目中的错误处理

