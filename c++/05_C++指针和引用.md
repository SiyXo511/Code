# C++指针和引用

本教程将学习C++中的指针和引用，包括指针基础、引用基础、智能指针等。

## 1. 指针基础

### 指针声明和使用

```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 10;
    int* ptr = &x;  // 指针指向x的地址
    
    cout << "x的值: " << x << endl;
    cout << "x的地址: " << &x << endl;
    cout << "ptr的值（地址）: " << ptr << endl;
    cout << "ptr指向的值: " << *ptr << endl;
    
    // 通过指针修改值
    *ptr = 20;
    cout << "修改后x的值: " << x << endl;
    
    // 空指针
    int* null_ptr = nullptr;  // C++11推荐使用nullptr
    // int* null_ptr2 = NULL;  // C风格，不推荐
    
    return 0;
}
```

### 指针算术

```cpp
#include <iostream>
using namespace std;

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    int* ptr = arr;  // 指向数组首元素
    
    // 指针递增
    cout << *ptr << endl;  // 10
    ptr++;
    cout << *ptr << endl;  // 20
    
    // 指针递减
    ptr--;
    cout << *ptr << endl;  // 10
    
    // 指针加法
    ptr = ptr + 3;
    cout << *ptr << endl;  // 40
    
    // 指针减法
    int* ptr2 = arr + 4;
    cout << "距离: " << (ptr2 - ptr) << endl;
    
    // 通过指针遍历数组
    for (int* p = arr; p < arr + 5; p++) {
        cout << *p << " ";
    }
    cout << endl;
    
    return 0;
}
```

### 指针和数组

```cpp
#include <iostream>
using namespace std;

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    
    // 数组名是指向首元素的指针
    int* ptr = arr;
    
    // 以下等价
    cout << arr[0] << endl;
    cout << *arr << endl;
    cout << ptr[0] << endl;
    cout << *ptr << endl;
    
    // arr[i] 等价于 *(arr + i)
    for (int i = 0; i < 5; i++) {
        cout << *(arr + i) << " ";
    }
    cout << endl;
    
    return 0;
}
```

### 指针的指针

```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 10;
    int* ptr = &x;
    int** pptr = &ptr;  // 指针的指针
    
    cout << "x = " << x << endl;
    cout << "*ptr = " << *ptr << endl;
    cout << "**pptr = " << **pptr << endl;
    
    // 通过二级指针修改值
    **pptr = 20;
    cout << "修改后x = " << x << endl;
    
    return 0;
}
```

### 指向函数的指针

```cpp
#include <iostream>
using namespace std;

int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}

int main() {
    // 函数指针
    int (*func_ptr)(int, int);
    
    func_ptr = add;
    cout << func_ptr(10, 20) << endl;  // 30
    
    func_ptr = multiply;
    cout << func_ptr(10, 20) << endl;  // 200
    
    // 使用typedef简化
    typedef int (*Operation)(int, int);
    Operation op = add;
    cout << op(5, 3) << endl;
    
    return 0;
}
```

## 2. 引用基础

### 引用声明和使用

```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 10;
    int& ref = x;  // 引用是变量的别名
    
    cout << "x = " << x << endl;
    cout << "ref = " << ref << endl;
    
    // 通过引用修改值
    ref = 20;
    cout << "修改后x = " << x << endl;
    cout << "修改后ref = " << ref << endl;
    
    // 引用必须初始化
    // int& ref2;  // 错误：引用必须初始化
    
    // 引用不能重新绑定
    int y = 30;
    // ref = &y;  // 错误：引用不能重新绑定
    ref = y;  // 这是赋值，不是重新绑定
    
    return 0;
}
```

### 引用作为函数参数

```cpp
#include <iostream>
using namespace std;

// 按值传递（复制）
void swap_value(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}

// 按引用传递（不复制）
void swap_reference(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 10, y = 20;
    
    cout << "交换前: x=" << x << ", y=" << y << endl;
    
    swap_reference(x, y);
    cout << "交换后: x=" << x << ", y=" << y << endl;
    
    return 0;
}
```

### 引用作为返回值

```cpp
#include <iostream>
using namespace std;

int& get_element(int arr[], int index) {
    return arr[index];  // 返回引用
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    
    // 可以修改返回值
    get_element(arr, 0) = 100;
    
    cout << arr[0] << endl;  // 100
    
    // 注意：不能返回局部变量的引用
    // int& bad_ref() {
    //     int x = 10;
    //     return x;  // 错误：返回局部变量的引用
    // }
    
    return 0;
}
```

### const引用

```cpp
#include <iostream>
using namespace std;

// const引用不能修改
void print_value(const int& x) {
    cout << x << endl;
    // x = 100;  // 错误：const引用不能修改
}

int main() {
    int x = 10;
    const int& ref = x;  // const引用
    
    cout << ref << endl;
    // ref = 20;  // 错误：const引用不能修改
    
    x = 20;  // 可以修改原变量
    cout << ref << endl;  // ref也会改变
    
    // const引用可以绑定到临时对象
    const int& temp_ref = 100;
    cout << temp_ref << endl;
    
    return 0;
}
```

## 3. 指针和引用的区别

```cpp
#include <iostream>
using namespace std;

void compare_example() {
    int x = 10;
    
    // 指针
    int* ptr = &x;
    int* ptr2 = ptr;  // 可以重新赋值
    ptr = nullptr;    // 可以为空
    
    // 引用
    int& ref = x;
    // int& ref2;  // 错误：必须初始化
    // ref = nullptr;  // 错误：引用不能为空
    
    // 指针需要解引用
    cout << *ptr << endl;
    
    // 引用不需要解引用
    cout << ref << endl;
    
    // 指针有自己地址
    cout << "ptr的地址: " << &ptr << endl;
    
    // 引用没有自己地址（与原变量相同）
    cout << "ref的地址: " << &ref << endl;
    cout << "x的地址: " << &x << endl;
}
```

## 4. 智能指针（C++11）

### unique_ptr

```cpp
#include <iostream>
#include <memory>
using namespace std;

int main() {
    // unique_ptr：独占所有权
    unique_ptr<int> ptr(new int(10));
    
    cout << *ptr << endl;
    
    // 自动释放内存
    // 不需要手动delete
    
    // 不能复制，只能移动
    // unique_ptr<int> ptr2 = ptr;  // 错误：不能复制
    unique_ptr<int> ptr2 = move(ptr);  // 可以移动
    
    if (!ptr) {
        cout << "ptr已移动" << endl;
    }
    
    cout << *ptr2 << endl;
    
    // 使用make_unique（C++14）
    auto ptr3 = make_unique<int>(20);
    cout << *ptr3 << endl;
    
    return 0;
}
```

### shared_ptr

```cpp
#include <iostream>
#include <memory>
using namespace std;

int main() {
    // shared_ptr：共享所有权
    shared_ptr<int> ptr1 = make_shared<int>(10);
    shared_ptr<int> ptr2 = ptr1;  // 可以复制
    
    cout << "引用计数: " << ptr1.use_count() << endl;  // 2
    
    {
        shared_ptr<int> ptr3 = ptr1;
        cout << "引用计数: " << ptr1.use_count() << endl;  // 3
    }  // ptr3离开作用域，引用计数减1
    
    cout << "引用计数: " << ptr1.use_count() << endl;  // 2
    
    // 当引用计数为0时，自动释放内存
    ptr1.reset();
    ptr2.reset();
    
    return 0;
}
```

### weak_ptr

```cpp
#include <iostream>
#include <memory>
using namespace std;

int main() {
    shared_ptr<int> shared = make_shared<int>(10);
    
    // weak_ptr：不增加引用计数
    weak_ptr<int> weak = shared;
    
    cout << "shared引用计数: " << shared.use_count() << endl;  // 1
    
    // 检查weak_ptr是否有效
    if (auto locked = weak.lock()) {
        cout << "weak_ptr有效，值: " << *locked << endl;
    }
    
    // 释放shared_ptr
    shared.reset();
    
    if (weak.expired()) {
        cout << "weak_ptr已过期" << endl;
    }
    
    return 0;
}
```

## 5. 动态内存分配

### new和delete

```cpp
#include <iostream>
using namespace std;

int main() {
    // 分配单个对象
    int* ptr = new int(10);
    cout << *ptr << endl;
    delete ptr;
    
    // 分配数组
    int* arr = new int[5]{1, 2, 3, 4, 5};
    for (int i = 0; i < 5; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    delete[] arr;  // 注意：数组要用delete[]
    
    // 使用智能指针更安全
    unique_ptr<int[]> arr2(new int[5]{10, 20, 30, 40, 50});
    for (int i = 0; i < 5; i++) {
        cout << arr2[i] << " ";
    }
    cout << endl;
    // 自动释放，不需要delete[]
    
    return 0;
}
```

## 6. 综合示例

### 使用智能指针管理资源

```cpp
#include <iostream>
#include <memory>
#include <vector>
using namespace std;

class Resource {
public:
    Resource(int id) : id(id) {
        cout << "Resource " << id << " 创建" << endl;
    }
    
    ~Resource() {
        cout << "Resource " << id << " 销毁" << endl;
    }
    
    void use() {
        cout << "使用Resource " << id << endl;
    }
    
private:
    int id;
};

int main() {
    // 使用unique_ptr
    {
        unique_ptr<Resource> res = make_unique<Resource>(1);
        res->use();
    }  // res自动释放
    
    // 使用shared_ptr
    {
        shared_ptr<Resource> res1 = make_shared<Resource>(2);
        shared_ptr<Resource> res2 = res1;
        res1->use();
        res2->use();
    }  // 当最后一个shared_ptr释放时，Resource才被销毁
    
    return 0;
}
```

## 练习

1. 编写一个函数，使用指针交换两个变量的值
2. 使用引用实现一个函数，计算两个数的和与差
3. 使用智能指针管理一个动态数组
4. 实现一个链表类，使用智能指针管理节点
5. 比较使用普通指针和智能指针的代码示例

