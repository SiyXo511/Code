# C++函数

本教程将学习C++中的函数，包括函数定义、参数传递、重载、默认参数、内联函数等。

## 1. 函数定义和调用

### 基本函数

```cpp
#include <iostream>
using namespace std;

// 函数声明
int add(int a, int b);

// 函数定义
int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(10, 20);
    cout << "结果: " << result << endl;
    return 0;
}
```

### void函数

```cpp
#include <iostream>
using namespace std;

void print_message(const string& msg) {
    cout << msg << endl;
}

int main() {
    print_message("Hello, C++!");
    return 0;
}
```

## 2. 函数参数传递

### 值传递

```cpp
#include <iostream>
using namespace std;

void swap_value(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    // a和b是副本，不会影响原变量
}

int main() {
    int x = 10, y = 20;
    cout << "交换前: x=" << x << ", y=" << y << endl;
    
    swap_value(x, y);
    cout << "交换后: x=" << x << ", y=" << y << endl;
    // x和y的值没有改变
    
    return 0;
}
```

### 指针传递

```cpp
#include <iostream>
using namespace std;

void swap_pointer(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int x = 10, y = 20;
    cout << "交换前: x=" << x << ", y=" << y << endl;
    
    swap_pointer(&x, &y);
    cout << "交换后: x=" << x << ", y=" << y << endl;
    // x和y的值已经交换
    
    return 0;
}
```

### 引用传递

```cpp
#include <iostream>
using namespace std;

void swap_reference(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 10, y = 20;
    cout << "交换前: x=" << x << ", y=" << y << endl;
    
    swap_reference(x, y);
    cout << "交换后: x=" << x << ", y=" << y << endl;
    // x和y的值已经交换
    
    return 0;
}
```

### const引用（推荐）

```cpp
#include <iostream>
#include <string>
using namespace std;

// 使用const引用，避免复制，同时防止修改
void print_string(const string& str) {
    cout << str << endl;
    // str = "changed";  // 错误：不能修改const引用
}

// 如果不需要修改参数，使用const引用
void print_number(const int& num) {
    cout << num << endl;
}

int main() {
    string msg = "Hello";
    print_string(msg);
    
    int x = 100;
    print_number(x);
    
    return 0;
}
```

## 3. 默认参数

```cpp
#include <iostream>
using namespace std;

// 默认参数必须从右到左
int power(int base, int exponent = 2) {
    int result = 1;
    for (int i = 0; i < exponent; i++) {
        result *= base;
    }
    return result;
}

void greet(const string& name = "Guest") {
    cout << "Hello, " << name << "!" << endl;
}

int main() {
    cout << power(3) << endl;      // 3^2 = 9（使用默认参数）
    cout << power(3, 3) << endl;   // 3^3 = 27
    
    greet();           // "Hello, Guest!"
    greet("Alice");    // "Hello, Alice!"
    
    return 0;
}
```

## 4. 函数重载

```cpp
#include <iostream>
using namespace std;

// 函数重载：同名函数，不同参数
int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}

int add(int a, int b, int c) {
    return a + b + c;
}

int main() {
    cout << add(10, 20) << endl;          // 调用 int add(int, int)
    cout << add(3.14, 2.71) << endl;      // 调用 double add(double, double)
    cout << add(1, 2, 3) << endl;         // 调用 int add(int, int, int)
    
    return 0;
}
```

### 重载规则

```cpp
#include <iostream>
using namespace std;

// 不同的参数类型
void print(int x) {
    cout << "整数: " << x << endl;
}

void print(double x) {
    cout << "浮点数: " << x << endl;
}

void print(const string& x) {
    cout << "字符串: " << x << endl;
}

// 不同的参数个数
void print(int a, int b) {
    cout << "两个整数: " << a << ", " << b << endl;
}

int main() {
    print(10);
    print(3.14);
    print("Hello");
    print(10, 20);
    
    return 0;
}
```

## 5. 内联函数

```cpp
#include <iostream>
using namespace std;

// 内联函数：编译器会在调用处展开代码
inline int square(int x) {
    return x * x;
}

// 适合小函数，避免函数调用开销
inline int max(int a, int b) {
    return (a > b) ? a : b;
}

int main() {
    int x = 5;
    cout << square(x) << endl;  // 可能被展开为 x * x
    
    cout << max(10, 20) << endl;
    
    return 0;
}
```

## 6. 递归函数

```cpp
#include <iostream>
using namespace std;

// 计算阶乘
int factorial(int n) {
    if (n <= 1) {
        return 1;  // 基本情况
    }
    return n * factorial(n - 1);  // 递归调用
}

// 计算斐波那契数列
int fibonacci(int n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// 尾递归优化版本
int factorial_tail(int n, int acc = 1) {
    if (n <= 1) {
        return acc;
    }
    return factorial_tail(n - 1, n * acc);
}

int main() {
    cout << "5! = " << factorial(5) << endl;
    cout << "斐波那契(10) = " << fibonacci(10) << endl;
    cout << "5! = " << factorial_tail(5) << endl;
    
    return 0;
}
```

## 7. 函数指针

```cpp
#include <iostream>
using namespace std;

int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}

int main() {
    // 函数指针
    int (*func_ptr)(int, int);
    
    func_ptr = add;
    cout << func_ptr(10, 20) << endl;  // 30
    
    func_ptr = multiply;
    cout << func_ptr(10, 20) << endl;  // 200
    
    // 使用typedef简化
    typedef int (*Operation)(int, int);
    Operation op = add;
    cout << op(5, 3) << endl;
    
    return 0;
}
```

### 函数指针作为参数

```cpp
#include <iostream>
using namespace std;

int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }
int multiply(int a, int b) { return a * b; }

// 函数指针作为参数
int calculate(int a, int b, int (*op)(int, int)) {
    return op(a, b);
}

int main() {
    cout << calculate(10, 5, add) << endl;        // 15
    cout << calculate(10, 5, subtract) << endl;   // 5
    cout << calculate(10, 5, multiply) << endl;   // 50
    
    return 0;
}
```

## 8. Lambda表达式（C++11）

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    // 基本lambda
    auto add = [](int a, int b) {
        return a + b;
    };
    cout << add(10, 20) << endl;
    
    // 捕获外部变量（按值）
    int x = 10;
    auto multiply = [x](int y) {
        return x * y;
    };
    cout << multiply(5) << endl;
    
    // 捕获外部变量（按引用）
    int sum = 0;
    vector<int> vec = {1, 2, 3, 4, 5};
    for_each(vec.begin(), vec.end(), [&sum](int n) {
        sum += n;
    });
    cout << "总和: " << sum << endl;
    
    // 捕获所有变量
    int a = 10, b = 20;
    auto lambda1 = [=]() { return a + b; };  // 按值捕获所有
    auto lambda2 = [&]() { return a + b; };  // 按引用捕获所有
    
    // 捕获部分变量
    auto lambda3 = [a, &b]() { return a + b; };  // a按值，b按引用
    
    return 0;
}
```

## 9. 变长参数函数

### 使用initializer_list（C++11）

```cpp
#include <iostream>
#include <initializer_list>
using namespace std;

int sum(initializer_list<int> nums) {
    int result = 0;
    for (int num : nums) {
        result += num;
    }
    return result;
}

int main() {
    cout << sum({1, 2, 3, 4, 5}) << endl;
    cout << sum({10, 20, 30}) << endl;
    
    return 0;
}
```

### 使用可变参数模板（C++11）

```cpp
#include <iostream>
using namespace std;

// 基础模板
template<typename T>
T sum_args(T value) {
    return value;
}

// 递归模板
template<typename T, typename... Args>
T sum_args(T first, Args... args) {
    return first + sum_args(args...);
}

int main() {
    cout << sum_args(1, 2, 3, 4, 5) << endl;
    cout << sum_args(10.5, 20.3, 30.2) << endl;
    
    return 0;
}
```

## 10. 综合示例

### 函数对象（Functor）

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// 函数对象类
class Multiplier {
private:
    int factor;
public:
    Multiplier(int f) : factor(f) {}
    
    int operator()(int x) const {
        return x * factor;
    }
};

int main() {
    vector<int> vec = {1, 2, 3, 4, 5};
    Multiplier mult(3);
    
    // 使用函数对象
    transform(vec.begin(), vec.end(), vec.begin(), mult);
    
    for (int x : vec) {
        cout << x << " ";
    }
    cout << endl;
    
    return 0;
}
```

## 练习

1. 编写一个函数，判断一个数是否为素数
2. 编写重载函数，计算不同类型数据的最大值
3. 使用递归实现二分查找
4. 使用lambda表达式对vector进行排序
5. 实现一个函数模板，可以计算任意类型数组的和

