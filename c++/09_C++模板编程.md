# C++模板编程

本教程将学习C++中的模板编程，包括函数模板、类模板、模板特化等。

## 1. 函数模板

### 基本函数模板

```cpp
#include <iostream>
using namespace std;

// 函数模板
template<typename T>
T getMax(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    cout << getMax(10, 20) << endl;        // int版本
    cout << getMax(3.14, 2.71) << endl;    // double版本
    cout << getMax('a', 'z') << endl;      // char版本
    
    return 0;
}
```

### 多类型模板参数

```cpp
#include <iostream>
using namespace std;

// 多个模板参数
template<typename T, typename U>
T add(T a, U b) {
    return a + b;
}

// 返回类型推导（C++14）
template<typename T, typename U>
auto multiply(T a, U b) -> decltype(a * b) {
    return a * b;
}

int main() {
    cout << add(10, 20.5) << endl;       // int + double
    cout << multiply(3, 4.5) << endl;    // int * double
    
    return 0;
}
```

### 模板参数推导

```cpp
#include <iostream>
#include <string>
using namespace std;

template<typename T>
void print(T value) {
    cout << value << endl;
}

template<typename T, typename U>
void print(T a, U b) {
    cout << a << ", " << b << endl;
}

int main() {
    print(10);                    // 自动推导为int
    print(3.14);                  // 自动推导为double
    print("Hello");               // 自动推导为const char*
    print(string("World"));       // 显式指定string
    print(10, 20.5);              // 多参数
    
    return 0;
}
```

## 2. 类模板

### 基本类模板

```cpp
#include <iostream>
using namespace std;

// 类模板
template<typename T>
class Stack {
private:
    T* data;
    int top;
    int capacity;
    
public:
    Stack(int size = 10) : capacity(size), top(-1) {
        data = new T[capacity];
    }
    
    ~Stack() {
        delete[] data;
    }
    
    void push(const T& item) {
        if (top < capacity - 1) {
            data[++top] = item;
        }
    }
    
    T pop() {
        if (top >= 0) {
            return data[top--];
        }
        return T();  // 返回默认值
    }
    
    bool empty() const {
        return top == -1;
    }
    
    int size() const {
        return top + 1;
    }
};

int main() {
    Stack<int> intStack;
    intStack.push(10);
    intStack.push(20);
    cout << intStack.pop() << endl;
    
    Stack<string> stringStack;
    stringStack.push("Hello");
    stringStack.push("World");
    cout << stringStack.pop() << endl;
    
    return 0;
}
```

### 多参数类模板

```cpp
#include <iostream>
using namespace std;

// 多个模板参数
template<typename T, int N>
class Array {
private:
    T data[N];
    
public:
    T& operator[](int index) {
        return data[index];
    }
    
    const T& operator[](int index) const {
        return data[index];
    }
    
    int size() const {
        return N;
    }
};

int main() {
    Array<int, 5> arr;
    for (int i = 0; i < arr.size(); i++) {
        arr[i] = i * 10;
    }
    
    for (int i = 0; i < arr.size(); i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    Array<string, 3> strArr;
    strArr[0] = "Hello";
    strArr[1] = "World";
    strArr[2] = "C++";
    
    for (int i = 0; i < strArr.size(); i++) {
        cout << strArr[i] << " ";
    }
    cout << endl;
    
    return 0;
}
```

## 3. 模板特化

### 函数模板特化

```cpp
#include <iostream>
#include <cstring>
using namespace std;

// 通用模板
template<typename T>
bool equal(T a, T b) {
    return a == b;
}

// 特化版本：const char*
template<>
bool equal<const char*>(const char* a, const char* b) {
    return strcmp(a, b) == 0;
}

int main() {
    cout << equal(10, 10) << endl;              // true
    cout << equal("Hello", "Hello") << endl;    // true（使用特化版本）
    
    return 0;
}
```

### 类模板特化

```cpp
#include <iostream>
using namespace std;

// 通用模板
template<typename T>
class Compare {
public:
    static bool less(T a, T b) {
        return a < b;
    }
};

// 全特化：针对指针类型
template<typename T>
class Compare<T*> {
public:
    static bool less(T* a, T* b) {
        return *a < *b;
    }
};

// 全特化：针对bool类型
template<>
class Compare<bool> {
public:
    static bool less(bool a, bool b) {
        return a && !b;  // 特殊逻辑
    }
};

int main() {
    cout << Compare<int>::less(5, 10) << endl;  // true
    
    int x = 5, y = 10;
    cout << Compare<int*>::less(&x, &y) << endl;  // true
    
    cout << Compare<bool>::less(true, false) << endl;  // true
    
    return 0;
}
```

### 偏特化

```cpp
#include <iostream>
using namespace std;

// 通用模板
template<typename T, typename U>
class Pair {
public:
    T first;
    U second;
    
    Pair(T f, U s) : first(f), second(s) {}
};

// 偏特化：当两个类型相同时
template<typename T>
class Pair<T, T> {
public:
    T first;
    T second;
    
    Pair(T f, T s) : first(f), second(s) {}
    
    // 额外的方法
    T sum() {
        return first + second;
    }
};

int main() {
    Pair<int, string> p1(1, "Hello");
    Pair<int, int> p2(10, 20);
    
    cout << p2.sum() << endl;  // 30（只有偏特化版本有sum方法）
    
    return 0;
}
```

## 4. 可变参数模板（C++11）

```cpp
#include <iostream>
using namespace std;

// 基础情况：无参数
void print() {
    cout << endl;
}

// 递归情况：至少一个参数
template<typename T, typename... Args>
void print(T first, Args... args) {
    cout << first << " ";
    print(args...);  // 递归调用
}

int main() {
    print();
    print(1);
    print(1, 2);
    print(1, 2, 3, "Hello", 3.14);
    
    return 0;
}
```

### 展开参数包

```cpp
#include <iostream>
using namespace std;

// C++17: 折叠表达式
template<typename... Args>
auto sum(Args... args) {
    return (args + ...);  // 右折叠
}

template<typename... Args>
void print_all(Args... args) {
    ((cout << args << " "), ...);  // 左折叠
    cout << endl;
}

int main() {
    cout << sum(1, 2, 3, 4, 5) << endl;  // 15
    print_all(1, 2, 3, "Hello", 3.14);
    
    return 0;
}
```

## 5. 模板元编程

### 编译期计算

```cpp
#include <iostream>
using namespace std;

// 编译期计算阶乘
template<int N>
struct Factorial {
    static const int value = N * Factorial<N - 1>::value;
};

// 特化：基本情况
template<>
struct Factorial<0> {
    static const int value = 1;
};

// C++11: constexpr函数（更简单）
constexpr int factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n - 1);
}

int main() {
    cout << Factorial<5>::value << endl;  // 编译期计算
    cout << factorial(5) << endl;         // 编译期计算（如果传入常量）
    
    int x = 5;
    cout << factorial(x) << endl;         // 运行时计算
    
    return 0;
}
```

### 类型特征

```cpp
#include <iostream>
#include <type_traits>
using namespace std;

// 自定义类型特征
template<typename T>
struct IsPointer {
    static const bool value = false;
};

template<typename T>
struct IsPointer<T*> {
    static const bool value = true;
};

int main() {
    cout << IsPointer<int>::value << endl;     // false
    cout << IsPointer<int*>::value << endl;    // true
    
    // 使用标准库类型特征
    cout << is_pointer<int>::value << endl;    // false
    cout << is_pointer<int*>::value << endl;   // true
    cout << is_integral<int>::value << endl;   // true
    cout << is_floating_point<double>::value << endl;  // true
    
    return 0;
}
```

## 6. 综合示例

### 通用容器模板

```cpp
#include <iostream>
using namespace std;

template<typename T>
class Vector {
private:
    T* data;
    int size;
    int capacity;
    
public:
    Vector(int cap = 10) : size(0), capacity(cap) {
        data = new T[capacity];
    }
    
    ~Vector() {
        delete[] data;
    }
    
    void push_back(const T& item) {
        if (size >= capacity) {
            // 扩容
            capacity *= 2;
            T* newData = new T[capacity];
            for (int i = 0; i < size; i++) {
                newData[i] = data[i];
            }
            delete[] data;
            data = newData;
        }
        data[size++] = item;
    }
    
    T& operator[](int index) {
        return data[index];
    }
    
    int getSize() const {
        return size;
    }
};

int main() {
    Vector<int> vec;
    vec.push_back(10);
    vec.push_back(20);
    vec.push_back(30);
    
    for (int i = 0; i < vec.getSize(); i++) {
        cout << vec[i] << " ";
    }
    cout << endl;
    
    return 0;
}
```

## 练习

1. 实现一个通用的Pair模板类
2. 创建一个模板函数，计算数组的最大值和最小值
3. 实现一个模板函数，对容器进行排序
4. 创建一个模板类Matrix，支持矩阵运算
5. 使用模板元编程计算斐波那契数列

